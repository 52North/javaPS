{
    "docs": [
        {
            "location": "/",
            "text": "JavaPS Documentation\n\n\nThis documentation guide provides helpful information about the \nJavaPS\n Java project, developed by \n52\u00b0North\n. This documentation is based on the project state from December 2016. The most current development of \nJavaPS\n is available from the \nofficial GitHub repository\n.\n\n\nGeneral Information\n\n\nThis section provides general information about the \nJavaPS\n project, which offers a state-of-the-art implementation of an OGC \nWeb Processing Service (WPS)\n version 2.0.0.\n\n\nFrom an architectural point of view, \nJavaPS\n is based on the generic \nIceland\n project, equally developed and maintained by \n52\u00b0North\n. \nIceland\n represents a generic Java framework for OGC Web Services. Hence it offers a generic service infrastructure implementation in accordance to the \nOGC Web Service Common\n specification. On top of this generic service infrastructure, \nIceland\n can be extended to implement concrete web services. As an example, \nJavaPS\n utilizes \nIceland\n to become a well-designed Web Processing Service. For this reason, \nJavaPS\n provides key Java components such as \nrequest objects\n, \nresponse objects\n, \ndecoders\n, \nencoders\n, \nparsers\n as well as other components related to OGC WPS.\n\n\nLinks to Subpages of the Documentation\n\n\nWithin this documentation, several aspects of the implementation are addressed. The documentation is split across the following sub pages, each focusing a certain aspect:\n\n\n\n\nnotes on architectural aspects are presented within page \nArchitectural Details\n\n\nthe dynamic interplay of \nIceland's\n and \nJavaPS's\n components is focused on page \nSequence Diagrams\n. Is makes use of UML sequence diagrams to show the method calls from receiving a WPS request to sending the response.\n\n\nrecommendations and explanations on how to add custom processes (as executable algorithms) to \nJavaPS\n are provided on page \nHow to add new Processes/Algorithms\n.",
            "title": "Home"
        },
        {
            "location": "/#javaps-documentation",
            "text": "This documentation guide provides helpful information about the  JavaPS  Java project, developed by  52\u00b0North . This documentation is based on the project state from December 2016. The most current development of  JavaPS  is available from the  official GitHub repository .",
            "title": "JavaPS Documentation"
        },
        {
            "location": "/#general-information",
            "text": "This section provides general information about the  JavaPS  project, which offers a state-of-the-art implementation of an OGC  Web Processing Service (WPS)  version 2.0.0.  From an architectural point of view,  JavaPS  is based on the generic  Iceland  project, equally developed and maintained by  52\u00b0North .  Iceland  represents a generic Java framework for OGC Web Services. Hence it offers a generic service infrastructure implementation in accordance to the  OGC Web Service Common  specification. On top of this generic service infrastructure,  Iceland  can be extended to implement concrete web services. As an example,  JavaPS  utilizes  Iceland  to become a well-designed Web Processing Service. For this reason,  JavaPS  provides key Java components such as  request objects ,  response objects ,  decoders ,  encoders ,  parsers  as well as other components related to OGC WPS.",
            "title": "General Information"
        },
        {
            "location": "/#links-to-subpages-of-the-documentation",
            "text": "Within this documentation, several aspects of the implementation are addressed. The documentation is split across the following sub pages, each focusing a certain aspect:   notes on architectural aspects are presented within page  Architectural Details  the dynamic interplay of  Iceland's  and  JavaPS's  components is focused on page  Sequence Diagrams . Is makes use of UML sequence diagrams to show the method calls from receiving a WPS request to sending the response.  recommendations and explanations on how to add custom processes (as executable algorithms) to  JavaPS  are provided on page  How to add new Processes/Algorithms .",
            "title": "Links to Subpages of the Documentation"
        },
        {
            "location": "/architecture/architecture/",
            "text": "JavaPS Documentation - Architectural Details\n\n\nArchitectural Details\n\n\nJavaPS\n is based on another 52\u00b0North project named \nIceland\n. The following UML diagram highlights the core architectural aspects. To be precise, it shows the main components of \nIcelands\n generic infrastructure that ensures equal handling of different OGC Web services. Furthermore, the diagram also explains, how \nJavaPS\n extends the generic \nIceland\n infrastructure by offering several \nWPS\n specific components and Java implementations. Hereby, the notation of UML component diagrams is used. For clarification, the notation is explained in the following. On the left side, the three yellow boxes indicate the three tiers \nclient\n, \nserver\n and \ndata\n of classical 3-Tier Web service architectures. While the \nclient\n and \ndata\n tier contain few elements, the core attention should be paid on the \nserver\n tier. It illustrates that \nIceland\n provides the main infrastucture to handle client requests and manage the whole request lifecycle comprising the tasks request receival, identification of suitable request handler to process the request as well as the creation the response object. Hence, \nIceland\n is split into several key components, as shown in the subsequent diagram. While the blue coloured infrastructure components are completely provided by \nIceland\n, those coloured in cyan are implemented and offered by \nJavaPS\n to create a \nWPS\n specific application. For separation purposes the main components of \nJavaPS\n are coloured in red. Each components name is enclosed in \"<< >>\" to separate it from its description. Arrows within the diagram indicate that the connected resources work together. Where necessary, arrows are annotated to clarify their task.\n\n\nSystem Architecture\n\n\nSubsequently, the basic components and their interaction and dependencies are explained. First \nIceland\n components are explained. Afterwards, special attention is paid to the additions provided by \nJavaPS\n.\n\n\nIceland\n:\n\n\n\n\nIceland\n - \nServlet/Service\n: \nIceland\n is based on the open source \nSpring Framework\n, which offers essential receival of incoming requests as well as other benefits like dependency injection and bean/component handling. Hence, the \nServlet\n component within \nIceland\n is offered by \nSpring\n (so-called \nDispatcherServlet\n). Building on Springs infrastructure, \nIceland\n provides a \nService\n component as central \nSpring Controller\n. Note that a \nSpring Controller\n is required to handle incoming Web requests within the application. While in theory, an application may implement multiple \nControllers\n, \nIceland\n uses a single \nSpring Controller\n to react on arbitrary Web requests targeting different OGC Web service operations (e.g. \nGetCapabilities\n or \nWPS\n \nDescribeProcess\n operation).\n\n\nIceland\n - \nBinding\n and \ncoding\n: After receival of a request, the \nBinding\n component uses \nde-\n and \nencoders\n to determine the \nbinding\n of the request. Possible bindings might be \nKVP\n (Key Value Pair) for HTTP GET or \nPOX\n (Plain Old XML), \nSOAP\n (Simple Object Access Protocol) and \nJSON\n (JavaScript Object Notation) for HTTP POST requests. For each \nbinding\n, a separate implementation exists to properly parse the request. Here, \nJavaPS\n may implement additional \nBindings\n or \nde-\n and \nencoders\n specific for \nWPS\n operations and register them via Spring configuration files as explained \nbelow\n.\n\n\nIceland\n - \nOperator\n: As \nIceland\n is organised in a generic manner, it provides generic components \nServiceOperator\n and \nRequestOperator\n to manage arbitrary OGC request from arbitrary OGC Web services. They are used to derive the appropriate \nRequest\n object and \nOperationHandler\n, as described next.\n\n\nIceland\n - \nRequest\n, \nResponse\n and \nOperationHandler\n: For each supported operation of an OGC Web service, \nIceland\n requires suitable \nRequest\n, \nResponse\n and \nOperationHandler\n implementations. However, each different OGC Web service defines different \noperations\n that have to be supported. Only the \nGetCapabilities\n operation is equal for \nALL\n OGC Web services and is thus directly implemented within \nIceland\n (to be correct, only the \nGetCapabilitiesHandler\n has to be provided by \nJavaPS\n). Hence, \nJavaPS\n provides the missing \nWPS\n \nRequest\n, \nResponse\n and \nOperationHandler\n implementations for the operations \nDescribeProcess\n, \nExecute\n, \nGetStatus\n, \nGetResult\n and \nDismiss\n. The general workflow uses the \nOperationHandler\n to extract and process the information from the \nRequest\n object and to compute the associated \nResponse\n object.\n\n\nIceland\n - \nContent Cache\n: As mentioned above, the \nGetCapabilities\n operation handling is completely implemented within \nIceland\n (only the \nGetCapabilitiesHandler\n has to be provided by \nJavaPS\n). The \nCapabilities\n document contains basic information about the associated OGC Web service (service identification and service provider) as well as service specific details. E.g., for a WPS it contains information about available \nprocesses\n. To keep access to the storing data source minimal, \nIceland\n implements a \nCapabilities Content Cache\n that holds the necessary \nCapabilities information\n in main memory and which is updated on data changes or on a regular time interval. The benefit is a faster and resource-saving processing of \nGetCapabilities\n requests, as the information can be taken from main memory instead of extracting it from the original data source.\n\n\nIceland\n - \nDataSource\n: The \nDataSource\n component manages access to the underlying data source from the \nData Tier\n. This is especially necessary when updating the \nContent Cache\n described above.\n\n\n\n\nJavaPS\n:\n\n\nAs already explained, the generic infrastructure of \nIceland\n is concretized through \nJavaPS\n in order to create a \nWPS\n oriented Web application. For this reason, \nJavaPS\n supplements key components by specializing the abstract interfaces of \nIceland\n. In short, the following list presents the main parts of \nJavaPS\n:\n\n\n\n\nJavaPS\n - \nStream\n: A \nStreaming\n component supports \nIcelands\n \nBinding\n component and is used to read/parse requests and write responses.\n\n\nJavaPS\n - \nDecoders\n: In order to correctly parse requests, additional \nDecoders\n might be offered. This supplements the \nBinding\n component of \nIceland\n.\n\n\nJavaPS\n - \nWPS Classes\n: Additional \nWPS\n specific Java representations have to be provided within the scope of handling \nWPS\n operations. As exemplary components \nRequests\n and \nResponses\n are implemented and used within \nIcelands\n execution workflow. Of course, also the actual operation handling and job management within \nJavaPS\n requires several \nWPS\n specific Java classes. E.g., the following two components \nEngine\n and \nService\n also make use of \nWPS Classes\n.\n\n\nJavaPS\n - \nEngine\n: The \nEngine\n component implements the job and persistence management. In short it is responsible for planning and executing \nWPS\n processes/jobs and offer mechanisms to persist and retrieve computed results as well as general job information (e.g. \nJob Status\n). For instance, the \nEngine\n might use the local hard drive of the application server to persist job information within JSON files or complex output results as files of their own. A process is implemented as \nAlgorithm\n and the available \nAlgorithms\n are stored within \nAlgorithmRepositories\n. Not only can \nAlgorithms\n be implemented within \nJavaPS\n but can also be added via \nexternal Processing/Algorithm Repositories\n, that only offer additional \nAlgorithm\n implementations.\n\n\nJavaPS\n - \nService\n: The last main part of \nJavaPS\n is to provide implementations of \nOperationHandler\n and \nValidationHandler\n to handle \nWPS\n requests. Hence, for each \nWPS\n operation (\nGetCapabilities\n, \nDescribeProcess\n, \nExecute\n, \nGetStatus\n, \nGetResult\n, \nDismiss\n) , \nJavaPS\n implements one \nOperationHandler\n. \nValidationHandlers\n are required to check and validate each request. E.g. within some \nWPS\n operations, a parameter \njobId\n has to be included that references an existing process/algorithm within \nJavaPS\n, otherwise an exception can be thrown. By offering the appropriate \nOperationHandler\n, the responsibility of handling and answering \nWPS\n request is assigned to \nJavaPS\n. For most \nWPS\n requests, the \nOperationHandler\n make use of the \nEngine\n to perform actions related to a certain job (e.g. create and execute a new job or retrieve the results of finished jobs).\n\n\n\n\nOverview of Maven Modules\n\n\nJavaPS\n and \nIceland\n both use \nApache Maven\n as build automation tool to manage project dependencies and external libraries. \nJavaPS\n defines several sub-modules, each dedicated to a certain task. The following table shows each Maven module and its task:\n\n\nOverview of JavaPS Maven Modules and their Tasks\n\n\n\n\n\n\n\n\nMaven Module Name\n\n\nTask\n\n\n\n\n\n\n\n\n\n\ncore\n\n\nprovides Java representations of WPS requests and responses\n\n\n\n\n\n\nengine\n\n\nimplements the necessary processing engine to execute and manage jobs\n\n\n\n\n\n\niceland-stream\n\n\nprovides (XML) stream readers and writers\n\n\n\n\n\n\niceland-wps\n\n\nprovides elementary Java representations/implementations of all relevant WPS components defined within the official WPS 2.0 standard of the OGC\n\n\n\n\n\n\nkvp\n\n\nprovides additional KVP decoders for each WPS 2.0 operations (except Execute)\n\n\n\n\n\n\nservice\n\n\nprovides operation validators and handlers for each WPS 2.0 operation\n\n\n\n\n\n\nxml\n\n\nprovides helper components for interacting with XML requests/responses of WPS operations\n\n\n\n\n\n\nwebapp\n\n\nprovides deployment descriptor etc.\n\n\n\n\n\n\n\n\nSpring Bean Configuration\n\n\nIceland is based on the \nSpring Framework\n. By declaring certain Java classes as so-called \nbeans\n, Spring's \ndependency injection\n mechanism can be used to automatically inject these beans into other components. \nIceland\n and \nJavaPS\n make use of classic \nXML configuration\n files for bean declaration. For this reason, each Maven module of \nJavaPS\n comprises a number of \nbean declaration XML files\n that are located in \nsrc/main/resources/components/\n.",
            "title": "Architectural Details"
        },
        {
            "location": "/architecture/architecture/#javaps-documentation-architectural-details",
            "text": "",
            "title": "JavaPS Documentation - Architectural Details"
        },
        {
            "location": "/architecture/architecture/#architectural-details",
            "text": "JavaPS  is based on another 52\u00b0North project named  Iceland . The following UML diagram highlights the core architectural aspects. To be precise, it shows the main components of  Icelands  generic infrastructure that ensures equal handling of different OGC Web services. Furthermore, the diagram also explains, how  JavaPS  extends the generic  Iceland  infrastructure by offering several  WPS  specific components and Java implementations. Hereby, the notation of UML component diagrams is used. For clarification, the notation is explained in the following. On the left side, the three yellow boxes indicate the three tiers  client ,  server  and  data  of classical 3-Tier Web service architectures. While the  client  and  data  tier contain few elements, the core attention should be paid on the  server  tier. It illustrates that  Iceland  provides the main infrastucture to handle client requests and manage the whole request lifecycle comprising the tasks request receival, identification of suitable request handler to process the request as well as the creation the response object. Hence,  Iceland  is split into several key components, as shown in the subsequent diagram. While the blue coloured infrastructure components are completely provided by  Iceland , those coloured in cyan are implemented and offered by  JavaPS  to create a  WPS  specific application. For separation purposes the main components of  JavaPS  are coloured in red. Each components name is enclosed in \"<< >>\" to separate it from its description. Arrows within the diagram indicate that the connected resources work together. Where necessary, arrows are annotated to clarify their task.  System Architecture  Subsequently, the basic components and their interaction and dependencies are explained. First  Iceland  components are explained. Afterwards, special attention is paid to the additions provided by  JavaPS .  Iceland :   Iceland  -  Servlet/Service :  Iceland  is based on the open source  Spring Framework , which offers essential receival of incoming requests as well as other benefits like dependency injection and bean/component handling. Hence, the  Servlet  component within  Iceland  is offered by  Spring  (so-called  DispatcherServlet ). Building on Springs infrastructure,  Iceland  provides a  Service  component as central  Spring Controller . Note that a  Spring Controller  is required to handle incoming Web requests within the application. While in theory, an application may implement multiple  Controllers ,  Iceland  uses a single  Spring Controller  to react on arbitrary Web requests targeting different OGC Web service operations (e.g.  GetCapabilities  or  WPS   DescribeProcess  operation).  Iceland  -  Binding  and  coding : After receival of a request, the  Binding  component uses  de-  and  encoders  to determine the  binding  of the request. Possible bindings might be  KVP  (Key Value Pair) for HTTP GET or  POX  (Plain Old XML),  SOAP  (Simple Object Access Protocol) and  JSON  (JavaScript Object Notation) for HTTP POST requests. For each  binding , a separate implementation exists to properly parse the request. Here,  JavaPS  may implement additional  Bindings  or  de-  and  encoders  specific for  WPS  operations and register them via Spring configuration files as explained  below .  Iceland  -  Operator : As  Iceland  is organised in a generic manner, it provides generic components  ServiceOperator  and  RequestOperator  to manage arbitrary OGC request from arbitrary OGC Web services. They are used to derive the appropriate  Request  object and  OperationHandler , as described next.  Iceland  -  Request ,  Response  and  OperationHandler : For each supported operation of an OGC Web service,  Iceland  requires suitable  Request ,  Response  and  OperationHandler  implementations. However, each different OGC Web service defines different  operations  that have to be supported. Only the  GetCapabilities  operation is equal for  ALL  OGC Web services and is thus directly implemented within  Iceland  (to be correct, only the  GetCapabilitiesHandler  has to be provided by  JavaPS ). Hence,  JavaPS  provides the missing  WPS   Request ,  Response  and  OperationHandler  implementations for the operations  DescribeProcess ,  Execute ,  GetStatus ,  GetResult  and  Dismiss . The general workflow uses the  OperationHandler  to extract and process the information from the  Request  object and to compute the associated  Response  object.  Iceland  -  Content Cache : As mentioned above, the  GetCapabilities  operation handling is completely implemented within  Iceland  (only the  GetCapabilitiesHandler  has to be provided by  JavaPS ). The  Capabilities  document contains basic information about the associated OGC Web service (service identification and service provider) as well as service specific details. E.g., for a WPS it contains information about available  processes . To keep access to the storing data source minimal,  Iceland  implements a  Capabilities Content Cache  that holds the necessary  Capabilities information  in main memory and which is updated on data changes or on a regular time interval. The benefit is a faster and resource-saving processing of  GetCapabilities  requests, as the information can be taken from main memory instead of extracting it from the original data source.  Iceland  -  DataSource : The  DataSource  component manages access to the underlying data source from the  Data Tier . This is especially necessary when updating the  Content Cache  described above.   JavaPS :  As already explained, the generic infrastructure of  Iceland  is concretized through  JavaPS  in order to create a  WPS  oriented Web application. For this reason,  JavaPS  supplements key components by specializing the abstract interfaces of  Iceland . In short, the following list presents the main parts of  JavaPS :   JavaPS  -  Stream : A  Streaming  component supports  Icelands   Binding  component and is used to read/parse requests and write responses.  JavaPS  -  Decoders : In order to correctly parse requests, additional  Decoders  might be offered. This supplements the  Binding  component of  Iceland .  JavaPS  -  WPS Classes : Additional  WPS  specific Java representations have to be provided within the scope of handling  WPS  operations. As exemplary components  Requests  and  Responses  are implemented and used within  Icelands  execution workflow. Of course, also the actual operation handling and job management within  JavaPS  requires several  WPS  specific Java classes. E.g., the following two components  Engine  and  Service  also make use of  WPS Classes .  JavaPS  -  Engine : The  Engine  component implements the job and persistence management. In short it is responsible for planning and executing  WPS  processes/jobs and offer mechanisms to persist and retrieve computed results as well as general job information (e.g.  Job Status ). For instance, the  Engine  might use the local hard drive of the application server to persist job information within JSON files or complex output results as files of their own. A process is implemented as  Algorithm  and the available  Algorithms  are stored within  AlgorithmRepositories . Not only can  Algorithms  be implemented within  JavaPS  but can also be added via  external Processing/Algorithm Repositories , that only offer additional  Algorithm  implementations.  JavaPS  -  Service : The last main part of  JavaPS  is to provide implementations of  OperationHandler  and  ValidationHandler  to handle  WPS  requests. Hence, for each  WPS  operation ( GetCapabilities ,  DescribeProcess ,  Execute ,  GetStatus ,  GetResult ,  Dismiss ) ,  JavaPS  implements one  OperationHandler .  ValidationHandlers  are required to check and validate each request. E.g. within some  WPS  operations, a parameter  jobId  has to be included that references an existing process/algorithm within  JavaPS , otherwise an exception can be thrown. By offering the appropriate  OperationHandler , the responsibility of handling and answering  WPS  request is assigned to  JavaPS . For most  WPS  requests, the  OperationHandler  make use of the  Engine  to perform actions related to a certain job (e.g. create and execute a new job or retrieve the results of finished jobs).",
            "title": "Architectural Details"
        },
        {
            "location": "/architecture/architecture/#overview-of-maven-modules",
            "text": "JavaPS  and  Iceland  both use  Apache Maven  as build automation tool to manage project dependencies and external libraries.  JavaPS  defines several sub-modules, each dedicated to a certain task. The following table shows each Maven module and its task:  Overview of JavaPS Maven Modules and their Tasks     Maven Module Name  Task      core  provides Java representations of WPS requests and responses    engine  implements the necessary processing engine to execute and manage jobs    iceland-stream  provides (XML) stream readers and writers    iceland-wps  provides elementary Java representations/implementations of all relevant WPS components defined within the official WPS 2.0 standard of the OGC    kvp  provides additional KVP decoders for each WPS 2.0 operations (except Execute)    service  provides operation validators and handlers for each WPS 2.0 operation    xml  provides helper components for interacting with XML requests/responses of WPS operations    webapp  provides deployment descriptor etc.",
            "title": "Overview of Maven Modules"
        },
        {
            "location": "/architecture/architecture/#spring-bean-configuration",
            "text": "Iceland is based on the  Spring Framework . By declaring certain Java classes as so-called  beans , Spring's  dependency injection  mechanism can be used to automatically inject these beans into other components.  Iceland  and  JavaPS  make use of classic  XML configuration  files for bean declaration. For this reason, each Maven module of  JavaPS  comprises a number of  bean declaration XML files  that are located in  src/main/resources/components/ .",
            "title": "Spring Bean Configuration"
        },
        {
            "location": "/sequence_diagrams/sequence_diagrams/",
            "text": "JavaPS Documentation - Sequence Diagrams\n\n\nSequence Diagrams demonstrating dynamic Interaction\n\n\nWithin the sub-pages various sequence diagrams are depicted to demonstrate the interactions between the main components of \nJavaPS\n. The presentation is split into two main sections:\n\n\n\n\nan \nabstract workflow description\n that demonstrates the main steps from any WPS request to its response. It is independent from concrete WPS operations.\n\n\nthe \nworkflow descriptions of all WPS 2.0 operations\n, which reveals details on request validation and handling for each of the WPS operations.",
            "title": "Introduction"
        },
        {
            "location": "/sequence_diagrams/sequence_diagrams/#javaps-documentation-sequence-diagrams",
            "text": "",
            "title": "JavaPS Documentation - Sequence Diagrams"
        },
        {
            "location": "/sequence_diagrams/sequence_diagrams/#sequence-diagrams-demonstrating-dynamic-interaction",
            "text": "Within the sub-pages various sequence diagrams are depicted to demonstrate the interactions between the main components of  JavaPS . The presentation is split into two main sections:   an  abstract workflow description  that demonstrates the main steps from any WPS request to its response. It is independent from concrete WPS operations.  the  workflow descriptions of all WPS 2.0 operations , which reveals details on request validation and handling for each of the WPS operations.",
            "title": "Sequence Diagrams demonstrating dynamic Interaction"
        },
        {
            "location": "/sequence_diagrams/workflow_general/general_workflow/",
            "text": "JavaPS Documentation - Generic Workflow from Request to Response\n\n\nIn order to better understand the dynamic relationships between the participating service components this section uses a variety of UML sequence diagrams showing the method workflow during key WPS operations. This section is structured as follows: First, an \nabstract workflow description\n from an arbitrary request to its response is demonstrated. Within this description the documentation highlights, how the request binding is determined (\nBinding in detail\n) and how the request is parsed (\nParsing in detail\n). The actual implementation of each \nWPS 2.0 operation\n (\nGetCapabilities\n, \nDescribeProcess\n, \nExecute\n, \nGetStatus\n, \nGetResult\n, \nDismiss\n) is introduced on the separate page \nWorkflow of WPS 2.0 operations\n.\n\n\nThroughout all sequence diagrams the UML sequence diagram notation is used. In addition, the colours (\nblue\n and \nred\n) of the participating application components indicate their membership within either \nJavaPS\n or \nIceland\n. While \nblue\n components belong to \nIceland\n, \nred\n components are offered by \nJavaPS\n.\n\n\nGeneral Workflow (abstract Request to Response)\n\n\nIn this section, the workflow and main method calls between key components of \nJavaPS\n and \nIceland\n are described in an abstract way. It comprises a \ngeneric workflow description\n, including an overview of \nservice events\n as well as detailed descriptions of \nbinding identification\n and \nrequest parsing\n.\n\n\nConcrete operation workflows with particular focus on \nrequest handling\n are explained in section \nWorkflow of WPS 2.0 operations\n.\n\n\nOverview from Request to Response\n\n\nFirst a general overview is presented subsequently. It shows the main processing steps and participating components from \nreceiving a request\n to \nreturning the response\n.\n\n\nGeneric Workflow\n\n\nAs \nJavaPS\n / \nIceland\n is build on Spring, the \nService\n component acts as the central Spring controller, receiving any incoming request. For each WPS request its processing is structured in the following subtasks:\n\n\n\n\ndetermine the \nBinding\n (e.g. KVP, POX, SOAP, JSON) from the request. This will identify a certain \nBinding\n implementation from \nIceland\n. How the \nBinding\n is determined is explained in section \nIdentification of Binding in detail\n.\n\n\ncall the \ndoXOperation()\n method from the found \nBinding\n component. Here the \nX\n indicates that different \nBinding\n implementations use different \ndo\n-operations. E.g. a GET request is usually handled by a \nKvpBinding\n component, which offers a \ndoGetOperation()\n method. Opposite a POST request is handled by a \nBinding\n implementation that has a \ndoPostOperation()\n method.\n\n\nthe request is \nparsed\n and transformed into the associated \nRequest\n object. The request \nparsing\n is explained in section \nParsing of a Request in detail\n.\n\n\ndetermine the \nservice operator\n that \nreceives\n the request. \nIceland\n offers a \nGenericServiceOperator\n component, which is used for all possible WPS requests. Hence the implementation is kept generic at this point.\n\n\nwithin the \nreceiveRequest()\n method, the generic \nservice operator\n fetches an appropriate \nrequest operator\n. Again \nIceland\n offers a generic implementation named \nGenericRequestOperator\n that can handle all types of WPS requests. However, as each request requires a different processing from this point onwards, the generic \nrequest operator\n is instantiated with request specific properties. For instance a \nRequestOperatorKey\n property stores the parameters \nservice\n, \nversion\n and \noperation name\n of an incoming request. Based on these properties, \nGenericRequestOperator\n is able to determine, which concrete other components are required during the next processing steps described below.\n\n\nas next step, the request needs to be \nvalidated\n by the request specific implementation of \nParameterValidator\n, e.g. by performing sanity checks on the delivered parameters or by checking certain values of request parameters. If a request parameter is missing or a non-existent resource is requested, an exception will be thrown. Relying on its request specific properties, the \nGenericRequestOperator\n knows, which validating component is responsible for this task. Note that the actual implementation of \nParameterValidator\n is located within \nJavaPS\n! The section \nWorkflow of WPS 2.0 operations\n contains detailed sequence diagrams of the validation process for each \nWPS\n operation.\n\n\nafter successful validation the appropriate \noperation handler\n is fetched from the \nOperationHandlerRepository\n. For each WPS request/operation (\nGetCapabilities\n, \nDescribeProcess\n, \nExecute\n, \nGetStatus\n, \nGetResult\n, \nDismiss\n), exactly one implementation of the interface \nOperationHandler\n exists. Each comprises a \nhandle()\n method to perform operation-specific processing steps. The section \nIdentification of Binding in detail\n describes how Iceland fetches the appropriate \nOperationHandler\n.\n\n\nthe \nOperationHandler\n implementation performs the necessary steps to process the request and eventually creates a request/operation specific \nResponse\n object. Note that the processing steps of each different request greatly vary. Detailed sequence diagrams of the \nrequest handling\n of each \nWPS operation\n are included in section \nWorkflow of WPS 2.0 operations\n.\n\n\nfinally, the response is forwarded to the \nBinding\n component, where it is properly \nwritten\n using output streams and the corresponding \nbinding\n. This will return the response to the client.\n\n\n\n\nIt has to be mentioned, that the diagram simplifies certain processing steps by hiding their complexity. For instance, the Identification of the binding includes several sub-tasks that are not reflected within the diagram. For this reason, some simplified steps are explained more detailed subsequently, comprising the \nidentification of binding\n and the \nparsing of requests\n. Before that, the next paragraph focuses several \nservice events\n that are triggered during operation handling.\n\n\nIceland Service Events throughout Operations\n\n\nAt several workflow points of the operation handling process described above, the \nIceland\n infrastructure fires special \nevents\n, for which \nlisteners\n may have registered before. For this reason, \nIceland\n implements a component named \nServiceEventBus\n, which is capable of managing events implementing the interface \nServiceEvent\n. It allows \nServiceEventListener\n components to register to certain \nServiceEvents\n and thus execute associated code once such an event is fired. For instance, some statistics can be managed through associated listeners. The following diagram shows a simplified Workflow diagram from a WPS request to response. In contrast to the previous workflow diagram it contains four additional \nServicEvent\n calls that are triggered for each possible WPS request:\n\n\n\n\nUpon receival of a new request the \nService\n component \nsubmits\n an \nIncomingRequestEvent\n to the \nServiceEventBus\n. This \nIncomingRequestEvent\n is a generic event and is independent from a concrete WPS operation.\n\n\nThe component \nGenericRequestOperator\n \nsubmits\n a \nRequestEvent\n before forwarding the request to the \nOperationHandler\n. A \nRequestEvent\n differs for each different WPS operation. It comprises a property \nrequest\n containing the concrete \nrequest object\n (e.g. a \nGetCapabilitiesRequest\n for a GetCapabilities operation).\n\n\nOnce the \nresponse\n is generated, the \nGenericRequestOperator\n \nsubmits\n a \nResponseEvent\n, which is also specific for each WPS operation as it comprises a \nresponse\n property that contains the concrete \nresponse object\n (e.g. a \nGetCapabilitiesResponse\n for a GetCapabilities operation).\n\n\nAs soon as the \nresponse\n has been \nwritten\n and send to the client, the \nService\n component \nsubmits\n the final \nOutgoingResponseEvent\n.\n\n\n\n\nService Events\n\n\nIdentification of Binding in detail\n\n\nDetails on how the application determines the \nbinding\n from the request are described in the following. First, an abstract generic workflow description is presented followed by two concrete examples (\nKVP Binding Example - GetCapabilities GET Request\n and \nPOX Binding Example - Execute POST Request\n).\n\n\nGeneric Workflow - Binding\n\n\nAs mentioned in the previous section, \nIceland\n offers a \nBinding\n interface. To determine the appropriate implementation for an incoming request, the \ncontent type\n (also called \nmedia type\n or \nmime type\n) is extracted and analysed.\n\n\nAs shown in the sequence diagram, the associated \ngetBinding()\n method consists of these main sub-tasks:\n\n\n\n\nget \nrequest URI\n and check if it is \nnull\n, \nempty\n or equals \"/\".\n\n\ndepending on the if-, determine the \ncontent type\n of the request or extract the \nprefix\n from the \nrequest URI\n.\n\n\nidentify the appropriate \nBinding\n implementation from the \nBindingRepository\n.\n\n\ncall the associated \ndoXOperation()\n method, where X either stands for \nGet\n or \nPost\n, depending on the returned binding.\n\n\n\n\nHowever, the first step is not as simple as it sounds. There are multiple \nif-cases\n that have to be resolved, as illustrated in the diagram.\n\n\nGeneric Workflow - Binding\n\n\nIn general, if the request is a \nGET\n request, then the content type is set to \napplication/x-kvp\n indicating that any \nGET\n request is associated to a KVP (Key Value Pair) binding. If otherwise it is a POST request then a \nMediaType\n object is created from the \ncontent type\n.\n\n\nTo concretize this abstract description, two examples are illustrated below. First an exemplar GET request (\nKVP\n binding) is demonstrated followed by an example of a POST request with \nPOX\n binding.\n\n\nKVP Binding Example for GET Request\n\n\nThe following diagram is based on the abstract binding-diagram from the previous section but instantiates the participating components to a \nGetCapabilities GET\n request. As a consequence, the implementation of the \nBinding\n interface is resolved to \nKvpBinding\n to handle a \nGET\n request. Furthermore, the diagram uses green colour to show the path within the various if-statements.\n\n\nKVP Binding Example\n\n\nPOX Binding Example for POST Request\n\n\nIn contrast to a \nGET\n request, the workflow of a \nPOST\n request differs. Again the green colour indicates the path within the if-statements. As it is a \nPOST\n request using a \nPOX\n (Plain Old XML) binding, the \ncontent type\n (\"application/xml\") is extracted from the request and used to identify the corresponding \nBinding\n implementation, which resolves to \nPoxBinding\n.\n\n\nPOX Binding Example\n\n\nParsing of a Request in detail\n\n\nThis section focuses on \nrequest parsing\n and presents more detailed workflow diagrams of this specific task. Similar to the detailed description of the binding identification, the presentation starts with a generic and abstract overview followed by two concrete examples (\nGetCapabilities GET Example\n and \nExecute POST Example\n).\n\n\nGeneric Workflow - Parse Request\n\n\nParsing of a request is executed by the \nBinding\n component. It analyses the request and fetches a suitable \nDecoder\n to parse the request. While the interface \nDecoder\n is located within \nIceland\n, its implementations are offered by \nJavaPS\n. As main sub-tasks the following actions are performed:\n\n\n\n\nthe \nWPS operation\n is determined from the request object.\n\n\nwith the help of the \noperation identification\n and the request \nmedia/content type\n, a new \nDecoderKey\n object is created.\n\n\nusing the \nDecoderKey\n, the appropriate \nDecoder\n implementation is retrieved from the \nDecoderRepository\n.\n\n\nvia the method \ndecode()\n of the \nDecoder\n, the request is transformed into the suitable instance of \nAbstractServiceRequest\n. Note that \nJavaPS\n offers exactly one implementation of \nAbstractServiceRequest\n for each WPS request/operation.\n\n\nafter instantiation of the request object it can be processed.\n\n\n\n\nGeneric Workflow - Parse Request\n\n\nThe following two sub-sections demonstrate request parsing including a \nGetCapabilities GET\n and an \nExecute POST\n request.\n\n\nCapabilities GET Example\n\n\nA \nGetCapabilities GET\n request is parsed by \nKvpBinding\n. First the \nparameter value map\n is extracted from the request and used to acquire \nservice\n (\"wps\"), \nversion\n (\"2.0.0\"), \noperation\n (\"GetCapabilities\") and \ncontent/media type\n (\"application/x-kvp\"). With this information, the \nDecoderKey\n is created and used to retrieve the \nGetCapabilitiesKvpDecoder\n from the \nDecoderRepository\n. Note that this decoder is specialized to handle \nGetCapabilities GET\n requests. Via its \ndecoder()\n method, which receives the \nparameter value map\n as argument, a \nGetCapabilitiesRequest\n instance is created and returned.\n\n\nParse Request - Capabilities GET Example\n\n\nExecute POST Example with POX Binding\n\n\nAn \nExecute POST\n request with \nPOX\n binding is parsed by \nPoxBinding\n. Since the request body is delivered as XML document, the \nPoxBinding\n first derives the \nencoding\n (\"UTF-8\") and parses the \nXML body\n as String. Via the method \ngetDecoderKey()\n, which takes the \nencoding\n and \nXML String\n as arguments, a new \nXmlStringOperationDecoderKey\n is created and used to retrieve the \nXmlStreamingOperationDecoder\n from the \nDecoderRepository\n.\n\n\nThen this decoder is used to read and parse the \nExecute\n request body String. \nJavaPS\n is designed to use \nstream readers\n to perform this task. It offers the interface \nStremReader\n and manages a repository of concrete child classes to parse the information from different formats. E.g. with regard to the XML body String of the request, an associated \nXmlStreamReaderKey\n is created to find the \nDocumentXmlStreamReader\n that extracts the required information from the XML String and creates an \nExecuteRequest\n instance.\n\n\nParse Request - Execute POST Example\n\n\nIdentification of OperationHandler in detail\n\n\nAnother interesting aspect of \nIceland's\n generic infrastructure is the \nidentification of a suitable OperationHandler\n, which processes a certain type of requests. As described in section \nOverview from Request to Response\n, the \nGenericRequestOperator\n possesses certain request-specific properties that aid during this step. In particular, it includes a property \nrequestOperatorKey\n of type \nRequestOperatorKey\n storing information about \nservice\n, \nversion\n and \noperation name\n of an incoming request. The diagram at the end of this section illustrates, how this information is used in order to fetch the correct \nOperationHandler\n from the associated \nOperationHandlerRepository\n. It comprises the following steps:\n\n\n\n\nWithin its \nreceiveRequest(request)\n method the \nGenericRequestOperator\n delegates the task of fetching the \nOperationHandler\n to its internal methods \ngetOperationHander()\n and \ngetOptionalOperationHandler()\n. The latter first retrieves the instance of \nOperationHandler\n as an \nOptional\n object to throw an exception in case no suitable handler is identified (as described in the final point of this list).\n\n\nFrom the aforementioned \nRequestOperatorKey\n, the request parameters \nservice\n and \noperationName\n are extracted. While \nservice\n always has to be set to \n\"WPS\"\n and is thus a constant value for all WPS request within the scope of \nJavaPS\n as a Web Processing Service implementation, the parameter \noperationName\n carries the operation the client targets. Possible Values are the operation specified in the \nOGC WPS 2.0 specification\n, i.e. \nGetCapabilities\n, \nDescribeProcess\n, \nExecute\n, \nGetStatus\n, \nGetResult\n, \nDismiss\n.\n\n\nservice\n and \nversion\n are then used as parameters when calling the \ngetOperationHander(service, operationName)\n method of \nOperationHandlerRepository\n.\n\n\nAmongst others, \nOperationHandlerRepository\n comprises a \nMap<OperationHandlerKey,Producer<OperationHandler>> operationHandlers\n property that maps an unambiguous \nOperationHandlerKey\n to its associated \nOperationHandler\n. The latter is wrapped by a \nProducer\n. In order to determine the correct \nOperationHandler\n, a new instance of \nOperationHandlerKey\n is created from both request parameters \nservice\n and \noperationName\n and used to retrieve the associated \nProducer\n from the \nMap\n object. In case of an invalid combination of \nservice\n and \noperationName\n, then no handler is found at all. The following table shows the possible combinations and to which handler they are resolved:\n\n\n\n\nValid combination of parameters \"service\" and \"operationName\"\n\n\n\n\n\n\n\n\nservice\n\n\noperationName\n\n\nOperationHandler instance\n\n\n\n\n\n\n\n\n\n\nWPS\n\n\nGetCapabilities\n\n\nGetCapabilitiesHandler\n\n\n\n\n\n\nWPS\n\n\nDescribeProcess\n\n\nDescribeProcessHandler\n\n\n\n\n\n\nWPS\n\n\nExecute\n\n\nExecuteHandler\n\n\n\n\n\n\nWPS\n\n\nGetStatus\n\n\nGetStatusHandler\n\n\n\n\n\n\nWPS\n\n\nGetResult\n\n\nGetResultHandler\n\n\n\n\n\n\nWPS\n\n\nDismiss\n\n\nDismissHandler\n\n\n\n\n\n\n\n\n\n\nFrom the returned \nProducer\n, the actual \nOperationHandler\n is extracted and then returned as an \nOptional\n.\n\n\nIf no valid \nOperationHandler\n could be found (i.e. the \nOptional\n contains \nNULL\n), a \nNullPointerException\n is thrown as the client requested an operation that is not supported by \nJavaPS\n. Otherwise, the \nOperationHandler\n is utilized to \nhandle()\n the request.\n\n\n\n\nIdentification of Operation Handler in detail",
            "title": "Generic Workflow Descriptions"
        },
        {
            "location": "/sequence_diagrams/workflow_general/general_workflow/#javaps-documentation-generic-workflow-from-request-to-response",
            "text": "In order to better understand the dynamic relationships between the participating service components this section uses a variety of UML sequence diagrams showing the method workflow during key WPS operations. This section is structured as follows: First, an  abstract workflow description  from an arbitrary request to its response is demonstrated. Within this description the documentation highlights, how the request binding is determined ( Binding in detail ) and how the request is parsed ( Parsing in detail ). The actual implementation of each  WPS 2.0 operation  ( GetCapabilities ,  DescribeProcess ,  Execute ,  GetStatus ,  GetResult ,  Dismiss ) is introduced on the separate page  Workflow of WPS 2.0 operations .  Throughout all sequence diagrams the UML sequence diagram notation is used. In addition, the colours ( blue  and  red ) of the participating application components indicate their membership within either  JavaPS  or  Iceland . While  blue  components belong to  Iceland ,  red  components are offered by  JavaPS .",
            "title": "JavaPS Documentation - Generic Workflow from Request to Response"
        },
        {
            "location": "/sequence_diagrams/workflow_general/general_workflow/#general-workflow-abstract-request-to-response",
            "text": "In this section, the workflow and main method calls between key components of  JavaPS  and  Iceland  are described in an abstract way. It comprises a  generic workflow description , including an overview of  service events  as well as detailed descriptions of  binding identification  and  request parsing .  Concrete operation workflows with particular focus on  request handling  are explained in section  Workflow of WPS 2.0 operations .",
            "title": "General Workflow (abstract Request to Response)"
        },
        {
            "location": "/sequence_diagrams/workflow_general/general_workflow/#overview-from-request-to-response",
            "text": "First a general overview is presented subsequently. It shows the main processing steps and participating components from  receiving a request  to  returning the response .  Generic Workflow  As  JavaPS  /  Iceland  is build on Spring, the  Service  component acts as the central Spring controller, receiving any incoming request. For each WPS request its processing is structured in the following subtasks:   determine the  Binding  (e.g. KVP, POX, SOAP, JSON) from the request. This will identify a certain  Binding  implementation from  Iceland . How the  Binding  is determined is explained in section  Identification of Binding in detail .  call the  doXOperation()  method from the found  Binding  component. Here the  X  indicates that different  Binding  implementations use different  do -operations. E.g. a GET request is usually handled by a  KvpBinding  component, which offers a  doGetOperation()  method. Opposite a POST request is handled by a  Binding  implementation that has a  doPostOperation()  method.  the request is  parsed  and transformed into the associated  Request  object. The request  parsing  is explained in section  Parsing of a Request in detail .  determine the  service operator  that  receives  the request.  Iceland  offers a  GenericServiceOperator  component, which is used for all possible WPS requests. Hence the implementation is kept generic at this point.  within the  receiveRequest()  method, the generic  service operator  fetches an appropriate  request operator . Again  Iceland  offers a generic implementation named  GenericRequestOperator  that can handle all types of WPS requests. However, as each request requires a different processing from this point onwards, the generic  request operator  is instantiated with request specific properties. For instance a  RequestOperatorKey  property stores the parameters  service ,  version  and  operation name  of an incoming request. Based on these properties,  GenericRequestOperator  is able to determine, which concrete other components are required during the next processing steps described below.  as next step, the request needs to be  validated  by the request specific implementation of  ParameterValidator , e.g. by performing sanity checks on the delivered parameters or by checking certain values of request parameters. If a request parameter is missing or a non-existent resource is requested, an exception will be thrown. Relying on its request specific properties, the  GenericRequestOperator  knows, which validating component is responsible for this task. Note that the actual implementation of  ParameterValidator  is located within  JavaPS ! The section  Workflow of WPS 2.0 operations  contains detailed sequence diagrams of the validation process for each  WPS  operation.  after successful validation the appropriate  operation handler  is fetched from the  OperationHandlerRepository . For each WPS request/operation ( GetCapabilities ,  DescribeProcess ,  Execute ,  GetStatus ,  GetResult ,  Dismiss ), exactly one implementation of the interface  OperationHandler  exists. Each comprises a  handle()  method to perform operation-specific processing steps. The section  Identification of Binding in detail  describes how Iceland fetches the appropriate  OperationHandler .  the  OperationHandler  implementation performs the necessary steps to process the request and eventually creates a request/operation specific  Response  object. Note that the processing steps of each different request greatly vary. Detailed sequence diagrams of the  request handling  of each  WPS operation  are included in section  Workflow of WPS 2.0 operations .  finally, the response is forwarded to the  Binding  component, where it is properly  written  using output streams and the corresponding  binding . This will return the response to the client.   It has to be mentioned, that the diagram simplifies certain processing steps by hiding their complexity. For instance, the Identification of the binding includes several sub-tasks that are not reflected within the diagram. For this reason, some simplified steps are explained more detailed subsequently, comprising the  identification of binding  and the  parsing of requests . Before that, the next paragraph focuses several  service events  that are triggered during operation handling.",
            "title": "Overview from Request to Response"
        },
        {
            "location": "/sequence_diagrams/workflow_general/general_workflow/#iceland-service-events-throughout-operations",
            "text": "At several workflow points of the operation handling process described above, the  Iceland  infrastructure fires special  events , for which  listeners  may have registered before. For this reason,  Iceland  implements a component named  ServiceEventBus , which is capable of managing events implementing the interface  ServiceEvent . It allows  ServiceEventListener  components to register to certain  ServiceEvents  and thus execute associated code once such an event is fired. For instance, some statistics can be managed through associated listeners. The following diagram shows a simplified Workflow diagram from a WPS request to response. In contrast to the previous workflow diagram it contains four additional  ServicEvent  calls that are triggered for each possible WPS request:   Upon receival of a new request the  Service  component  submits  an  IncomingRequestEvent  to the  ServiceEventBus . This  IncomingRequestEvent  is a generic event and is independent from a concrete WPS operation.  The component  GenericRequestOperator   submits  a  RequestEvent  before forwarding the request to the  OperationHandler . A  RequestEvent  differs for each different WPS operation. It comprises a property  request  containing the concrete  request object  (e.g. a  GetCapabilitiesRequest  for a GetCapabilities operation).  Once the  response  is generated, the  GenericRequestOperator   submits  a  ResponseEvent , which is also specific for each WPS operation as it comprises a  response  property that contains the concrete  response object  (e.g. a  GetCapabilitiesResponse  for a GetCapabilities operation).  As soon as the  response  has been  written  and send to the client, the  Service  component  submits  the final  OutgoingResponseEvent .   Service Events",
            "title": "Iceland Service Events throughout Operations"
        },
        {
            "location": "/sequence_diagrams/workflow_general/general_workflow/#identification-of-binding-in-detail",
            "text": "Details on how the application determines the  binding  from the request are described in the following. First, an abstract generic workflow description is presented followed by two concrete examples ( KVP Binding Example - GetCapabilities GET Request  and  POX Binding Example - Execute POST Request ).",
            "title": "Identification of Binding in detail"
        },
        {
            "location": "/sequence_diagrams/workflow_general/general_workflow/#generic-workflow-binding",
            "text": "As mentioned in the previous section,  Iceland  offers a  Binding  interface. To determine the appropriate implementation for an incoming request, the  content type  (also called  media type  or  mime type ) is extracted and analysed.  As shown in the sequence diagram, the associated  getBinding()  method consists of these main sub-tasks:   get  request URI  and check if it is  null ,  empty  or equals \"/\".  depending on the if-, determine the  content type  of the request or extract the  prefix  from the  request URI .  identify the appropriate  Binding  implementation from the  BindingRepository .  call the associated  doXOperation()  method, where X either stands for  Get  or  Post , depending on the returned binding.   However, the first step is not as simple as it sounds. There are multiple  if-cases  that have to be resolved, as illustrated in the diagram.  Generic Workflow - Binding  In general, if the request is a  GET  request, then the content type is set to  application/x-kvp  indicating that any  GET  request is associated to a KVP (Key Value Pair) binding. If otherwise it is a POST request then a  MediaType  object is created from the  content type .  To concretize this abstract description, two examples are illustrated below. First an exemplar GET request ( KVP  binding) is demonstrated followed by an example of a POST request with  POX  binding.",
            "title": "Generic Workflow - Binding"
        },
        {
            "location": "/sequence_diagrams/workflow_general/general_workflow/#kvp-binding-example-for-get-request",
            "text": "The following diagram is based on the abstract binding-diagram from the previous section but instantiates the participating components to a  GetCapabilities GET  request. As a consequence, the implementation of the  Binding  interface is resolved to  KvpBinding  to handle a  GET  request. Furthermore, the diagram uses green colour to show the path within the various if-statements.  KVP Binding Example",
            "title": "KVP Binding Example for GET Request"
        },
        {
            "location": "/sequence_diagrams/workflow_general/general_workflow/#pox-binding-example-for-post-request",
            "text": "In contrast to a  GET  request, the workflow of a  POST  request differs. Again the green colour indicates the path within the if-statements. As it is a  POST  request using a  POX  (Plain Old XML) binding, the  content type  (\"application/xml\") is extracted from the request and used to identify the corresponding  Binding  implementation, which resolves to  PoxBinding .  POX Binding Example",
            "title": "POX Binding Example for POST Request"
        },
        {
            "location": "/sequence_diagrams/workflow_general/general_workflow/#parsing-of-a-request-in-detail",
            "text": "This section focuses on  request parsing  and presents more detailed workflow diagrams of this specific task. Similar to the detailed description of the binding identification, the presentation starts with a generic and abstract overview followed by two concrete examples ( GetCapabilities GET Example  and  Execute POST Example ).",
            "title": "Parsing of a Request in detail"
        },
        {
            "location": "/sequence_diagrams/workflow_general/general_workflow/#generic-workflow-parse-request",
            "text": "Parsing of a request is executed by the  Binding  component. It analyses the request and fetches a suitable  Decoder  to parse the request. While the interface  Decoder  is located within  Iceland , its implementations are offered by  JavaPS . As main sub-tasks the following actions are performed:   the  WPS operation  is determined from the request object.  with the help of the  operation identification  and the request  media/content type , a new  DecoderKey  object is created.  using the  DecoderKey , the appropriate  Decoder  implementation is retrieved from the  DecoderRepository .  via the method  decode()  of the  Decoder , the request is transformed into the suitable instance of  AbstractServiceRequest . Note that  JavaPS  offers exactly one implementation of  AbstractServiceRequest  for each WPS request/operation.  after instantiation of the request object it can be processed.   Generic Workflow - Parse Request  The following two sub-sections demonstrate request parsing including a  GetCapabilities GET  and an  Execute POST  request.",
            "title": "Generic Workflow - Parse Request"
        },
        {
            "location": "/sequence_diagrams/workflow_general/general_workflow/#capabilities-get-example",
            "text": "A  GetCapabilities GET  request is parsed by  KvpBinding . First the  parameter value map  is extracted from the request and used to acquire  service  (\"wps\"),  version  (\"2.0.0\"),  operation  (\"GetCapabilities\") and  content/media type  (\"application/x-kvp\"). With this information, the  DecoderKey  is created and used to retrieve the  GetCapabilitiesKvpDecoder  from the  DecoderRepository . Note that this decoder is specialized to handle  GetCapabilities GET  requests. Via its  decoder()  method, which receives the  parameter value map  as argument, a  GetCapabilitiesRequest  instance is created and returned.  Parse Request - Capabilities GET Example",
            "title": "Capabilities GET Example"
        },
        {
            "location": "/sequence_diagrams/workflow_general/general_workflow/#execute-post-example-with-pox-binding",
            "text": "An  Execute POST  request with  POX  binding is parsed by  PoxBinding . Since the request body is delivered as XML document, the  PoxBinding  first derives the  encoding  (\"UTF-8\") and parses the  XML body  as String. Via the method  getDecoderKey() , which takes the  encoding  and  XML String  as arguments, a new  XmlStringOperationDecoderKey  is created and used to retrieve the  XmlStreamingOperationDecoder  from the  DecoderRepository .  Then this decoder is used to read and parse the  Execute  request body String.  JavaPS  is designed to use  stream readers  to perform this task. It offers the interface  StremReader  and manages a repository of concrete child classes to parse the information from different formats. E.g. with regard to the XML body String of the request, an associated  XmlStreamReaderKey  is created to find the  DocumentXmlStreamReader  that extracts the required information from the XML String and creates an  ExecuteRequest  instance.  Parse Request - Execute POST Example",
            "title": "Execute POST Example with POX Binding"
        },
        {
            "location": "/sequence_diagrams/workflow_general/general_workflow/#identification-of-operationhandler-in-detail",
            "text": "Another interesting aspect of  Iceland's  generic infrastructure is the  identification of a suitable OperationHandler , which processes a certain type of requests. As described in section  Overview from Request to Response , the  GenericRequestOperator  possesses certain request-specific properties that aid during this step. In particular, it includes a property  requestOperatorKey  of type  RequestOperatorKey  storing information about  service ,  version  and  operation name  of an incoming request. The diagram at the end of this section illustrates, how this information is used in order to fetch the correct  OperationHandler  from the associated  OperationHandlerRepository . It comprises the following steps:   Within its  receiveRequest(request)  method the  GenericRequestOperator  delegates the task of fetching the  OperationHandler  to its internal methods  getOperationHander()  and  getOptionalOperationHandler() . The latter first retrieves the instance of  OperationHandler  as an  Optional  object to throw an exception in case no suitable handler is identified (as described in the final point of this list).  From the aforementioned  RequestOperatorKey , the request parameters  service  and  operationName  are extracted. While  service  always has to be set to  \"WPS\"  and is thus a constant value for all WPS request within the scope of  JavaPS  as a Web Processing Service implementation, the parameter  operationName  carries the operation the client targets. Possible Values are the operation specified in the  OGC WPS 2.0 specification , i.e.  GetCapabilities ,  DescribeProcess ,  Execute ,  GetStatus ,  GetResult ,  Dismiss .  service  and  version  are then used as parameters when calling the  getOperationHander(service, operationName)  method of  OperationHandlerRepository .  Amongst others,  OperationHandlerRepository  comprises a  Map<OperationHandlerKey,Producer<OperationHandler>> operationHandlers  property that maps an unambiguous  OperationHandlerKey  to its associated  OperationHandler . The latter is wrapped by a  Producer . In order to determine the correct  OperationHandler , a new instance of  OperationHandlerKey  is created from both request parameters  service  and  operationName  and used to retrieve the associated  Producer  from the  Map  object. In case of an invalid combination of  service  and  operationName , then no handler is found at all. The following table shows the possible combinations and to which handler they are resolved:   Valid combination of parameters \"service\" and \"operationName\"     service  operationName  OperationHandler instance      WPS  GetCapabilities  GetCapabilitiesHandler    WPS  DescribeProcess  DescribeProcessHandler    WPS  Execute  ExecuteHandler    WPS  GetStatus  GetStatusHandler    WPS  GetResult  GetResultHandler    WPS  Dismiss  DismissHandler      From the returned  Producer , the actual  OperationHandler  is extracted and then returned as an  Optional .  If no valid  OperationHandler  could be found (i.e. the  Optional  contains  NULL ), a  NullPointerException  is thrown as the client requested an operation that is not supported by  JavaPS . Otherwise, the  OperationHandler  is utilized to  handle()  the request.   Identification of Operation Handler in detail",
            "title": "Identification of OperationHandler in detail"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/",
            "text": "JavaPS Documentation - Workflow of WPS 2.0 Operations\n\n\nWorkflow of WPS 2.0.0 Operations\n\n\nWithin the following sections the workflow of each operation of the WPS 2.0.0 standard that is supported by \nJavaPS\n is introduced in detail. Each description begins with a \ncoarse workflow\n overview of the operation, then focuses \nrequest validation\n and finally presents the \nrequest handling\n in detail. With regard to the \nrequest validation\n, \nJavaPS\n only comprises validating components that check each request object for WPS specific parameters. As \nIceland\n is a generic service infrastructure for numerous OCG Web services, it also performs the basic check of the standard parameters \n\"service\"\n, \n\"version\"\n and \n\"request\"\n. In particular, the value of the \n\"request\"\n parameter indicates, which WPS operation is requested and thus which \nValidationHandler\n and \nOperationHandler\n components are used. In the following, the operations \nGetCapabilities\n, \nDescribeProcess\n, \nExecute\n, \nGetStatus\n, \nGetResult\n and \nDismiss\n are focused.\n\n\nThroughout all sequence diagrams the UML sequence diagram notation is used. In addition, the colours (\nblue\n and \nred\n) of the participating application components indicate their membership within either \nJavaPS\n or \nIceland\n. While \nblue\n components belong to \nIceland\n, \nred\n components are offered by \nJavaPS\n.\n\n\nGetCapabilities\n\n\nGetCapabilities - Basic Workflow\n\n\nWithin the \nGetCapabilities\n operation the service capabilities of the WPS instance are retrieved. The subsequent diagram shows the coarse workflow between the participating system components for a \nGetCapabilities GET\n request. \nJavaPS\n uses \nKvpBinding\n to parse the request as a \nGetCapabilitiesRequest\n, validates the request with the help of \nGetCapabilitiesParameterValidator\n and request handling is done by \nGetCapabilitiesHandler\n. The latter returns a \nGetCapabilitiesResponse\n object including the retrieved capabilities.\n\n\nGetCapabilities Workflow coarse\n\n\nGetCapabilities - Request Validation\n\n\nAs of January 2017 there is no validation code for \nGetGapabilities\n operation.\n\n\nGetCapabilities - Detailed Request Handling\n\n\nTo highlight the request handling workflow the subsequent diagram focuses only the \nhandle()\n method of the \nGetCapabilitiesHandler\n. To increase response time of \nGetCapabilities\n requests against the WPS, \nIceland\n and \nJavaPS\n make use of a caching mechanism that holds the capabilities information within the memory for rapid access. Hereby, the capabilities information is extracted from the actual data source from time to time to keep the cached data up to date. When answering a \nGetCapabilities\n request, the data is directly read from the cached information and used to create the response object without accessing the actual data source.\n\n\nThe main tasks of the \nGetCapabilities\n request handling are:\n\n\n\n\nuse the \nGetCapabilitiesRequest\n object to create a \nGetCapabilitiesResponse\n object and set basic information about \nservice\n (\"WPS\") and \nversion\n (e.g. \"2.0.0\").\n\n\nthen inspect the \nGetCapabilitiesRequest\n object for the requested \nsections\n (filter for contents) and \nlocale\n (language). Available sections are:\n\n\nServiceIdentification\n - information about the WPS itself\n\n\nServiceProvider\n - information about the provider offering the WPS\n\n\nOperationsMetadata\n - information about the supported operations and bindings\n\n\nLanguages/Locales\n - information about available languages\n\n\nContents\n - information about processes offered by the WPS\n\n\n\n\n\n\nfor each of the above listed Capabilities sections the application inspects whether it is requested, and if so, extracts that information from the cached data. The sections \nServiceIdentification\n, \nServiceProvider\n and \nLanguages/Locales\n are stored within the \nServiceMetadataRepository\n. The \nOperationsMetadata\n is extracted from the \nRequestOperatorRepository\n and the available processes are extracted from the \nEngine\n. The \nEngine\n is a central component of \nJavaPS\n to manage jobs and processes and control their execution as well as persistence of job results. Each available process is represented by an instance of \nProcessOffering\n. The available processes are returned as \nSet\\<ProcessOffering>\n, from which a new instance of \nProcessOfferings\n is created.\n\n\nas \nIceland\n is a generic abstract framework for arbitrary OGC Web services it offers the component \nOwsCapabilities\n to include common \nCapabilities\n information. Hence an instance of \nOwsCapabilities\n is created from all requested section objects except the WPS specific \nProcessOfferings\n.\n\n\nfinally, a new instance of \nWPSCapabilities\n is created from \nOwsCapabilities\n and \nProcessOfferings\n, which is set within the \nGetCapabilitiesResponse\n and returned.\n\n\n\n\nGetCapabilities Workflow - handleRequest detailed\n\n\nDescribeProcess\n\n\nDescribeProcess - Basic Workflow\n\n\nThe \nDescribeProcess\n Operation is used by clients to retrieve the \nprocess description\n of a certain WPS process. The subsequent diagram shows the coarse workflow between the participating system components for a \nDescribeProcess GET\n request. \nJavaPS\n uses \nKvpBinding\n to parse the request as a \nDescribeProcessRequest\n, validates the request with the help of \nDescribeProcessParameterValidator\n and request handling is done by \nDescribeProcessHandler\n. The latter returns a \nDescribeProcessResponse\n object including the requested \nprocess description\n.\n\n\nDescribeProcess Workflow coarse\n\n\nDescribeProcess - Request Validation\n\n\nValidation of a \nDescribeProcess\n request is done by \nDescribeProcessParameterValidator\n and visualized in the diagram at the end of this section. Basically, a request has to contain the parameter \n\"identifier\"\n. Its value might be a reference to a single identifier of the associated process or a list of references to multiple processes or it may be the word \n\"ALL\"\n to request all process descriptions from the WPS. Hence, during validation, the \nDescribeProcessRequest\n object is analyzed for the existence of the required parameter. If it does not exist or is an empty value, a \nMissingParameterValueException\n is immediately thrown. Otherwise, each individual parameter value has to be checked. Before that an empty \nCompositeOwsException\n is created, which is used to collect any \nexception\n that might occur when checking each \nidentifier value\n. Validating a single \nidentifier value\n is split in two checks. First, if the \nidentifier value\n is a \nNULL\n object, then a \nMissingParameterValueException\n is added to \nCompositeOwsException\n. Second, the \nparameter value\n must reference an existing \nprocess\n within the WPS instance. To verify this, the \nEngine\n component is asked whether it contains an associated \nprocess description\n. If not, an \nInvalidParameterValueException\n is added to \nCompositeOwsException\n. Finally, as soon as each identifier has been checked, the \nCompositeOwsException\n object is analyzed. If it contains any \nexception\n, it is thrown as the request contained invalid or missing parameter values. If it empty, then validation was successful and the actual operation handling can be continued.\n\n\nDescribeProcess Request Validation\n\n\nAs indicated by the notes within the diagram, the upper description of the validation process have been simplified. Actually, Java Lambda expressions and \nOptional\n objects are used when creating an \nException\n first that are afterwards investigated to transfer any \nException\n to \nCompositeOwsException\n. For reasons of simplicity, the sequence diagram displays these steps in a different way.\n\n\nDescribeProcess - Detailed Request Handling\n\n\nThe subsequent diagram highlights the request handling of the \nDescribeProcess\n request. Basically, the \nprocess identifier\n is extracted from the \nDescribeProcessRequest\n and used to acquire the associated \nprocess description\n as \nProcessOffering\n. \nJavaPS\n organises available processes as child classes of interface \nIAlgorithm\n. Hence, a \nprocess\n is an \nIAlgorithm\n that has a \nprocess description\n as property and an \nexecute()\n method to run the algorithm.\n\n\nIn more detail, the following tasks are performed:\n\n\n\n\nextract \nprocess identifier\n from \nDescribeProcessRequest\n\n\ncall \ngetProcessDescription()\n method from \nEngine\n. Within this method, the \nEngine\n contacts the \nRepositoryManager\n to find a suitable \nAlgorithmRepository\n, from which the \nProcessDescription\n is retrieved.\n\n\nan instance of \nProcessOffering\n is created using the \nProcessDescription\n as parameter.\n\n\neventually a \nDescribeProcessResponse\n object is created from \nservice\n (\"WPS\") and \nversion\n (e.g. \"2.0.0\") and the \nProcessOffering\n and returned.\n\n\n\n\nDescribeProcess - handleRequest detailed\n\n\nExecute\n\n\nExecute - Basic Workflow\n\n\nIn contrast to the previous WPS \nGET\n operations examples, the \nExecute\n operation is demonstrated using HTTP \nPOST\n and \nPOX\n binding. With regard to the coarse workflow, the \nPoxBinding\n component parses the request as \nExecuteRequest\n within the \ndoPostOperation()\n method. The request is validated by \nExecuteParameterValidator\n, which performs a lot more checks compared to all other WPS operations as explained below. After validation, the \nExecuteHandler\n processes the request and returns an \nExecuteResponse\n. In short, a new \nJob\n instance is created that is executed synchronously or asynchronously. While in the first case (synchronous execution), the response contains the computed \nresult(s)\n, the latter case includes a \nstatus info\n document within the response.\n\n\nExecute Workflow coarse\n\n\nExecute - Request Validation\n\n\nValidation of an \nExecute\n requires much more steps compared to all other WPS operations. An \nExecute\n request comprises the following parameters:\n\n\n\n\nidentifier\n: the identifier of the process to be executed\n\n\ninput\n: one or more input definitions as process inputs. Hereby, inputs may be mandatory or optional and their cardinality (minimum and maximum occurrences) may be different. Also an input is defined using a certain format. The input value can be specified directly or might be given as a reference to a resource that must be fetched by the WPS first.\n\n\noutput\n: one or more output definitions as process outputs. Similar to the input definition, outputs may be mandatory or optional, uses a certain format and can be offered as value or as reference (URL to external resource).\n\n\nmode\n: the execution mode, whose value indicates \nsynchronous\n or \nasynchronous\n process execution.\n\n\nresponse\n: the response format, whose value indicates whether outputs shall be encoded as formal \nresponse document\n or as \nraw output\n.\n\n\n\n\nIn short, the validation of an \nExecute\n request comprises the following checks:\n\n\n\n\nvalidation of \nprocess identifier\n: is it missing or does it address a non-existent process?\n\n\nvalidation of \nresponse mode\n in combination with requested outputs: if it is set to \nRAW\n, then only one single output can be requested.\n\n\nvalidation of \ninputs\n: does \ninput identifier\n point to an existing \ninput\n of the selected process? Is the \ninput\n content defined correctly with regard to its description?\n\n\nvalidation of \noutputs\n: does \noutput identifier\n point to an existing \noutput\n of the selected process? Is the \noutput\n content defined correctly with regard to its description?\n\n\nvalidation of \ncardinalities\n: in general a process might require certain mandatory inputs. Also a process may restrict the number of certain inputs to a lower and upper boundary. Hence this check looks for missing mandatory inputs and inspects the numbers of included inputs.\n\n\n\n\nThe following sequence diagrams and sub-sections visualize these main steps. First a coarse overview is presented. Afterwards the validations of \ninputs\n, \noutputs\n and \ncardinalities\n are focused in more detail separately.\n\n\nCoarse Overview of Execute Request Validation\n\n\nValidation is performed by \nExecuteParameterValidator\n. Each individual step of the validation process may cause a certain \nException\n. Thus, as first step, a generic \nCompositeOwsException\n object is created, which is supposed to hold one ore multiple occurring \nExceptions\n to throw them as a composed object.\n\n\nThen the \nprocess identifier\n is extracted from the \nExecuteRequest\n. If it is missing, then a \nMissingParameterValueException\n for parameter \nidentifier\n is created and added to \nCompositeOwsException\n. Afterwards, the \nEngine\n component is used to retrieve the \nProcessDescription\n associated to the \nprocess identifier\n. If not description object can be found, an \nInvalidParameterValueException\n for parameter \nidentifier\n is created as the identifier does not point to an existing process within the \nWPS\n.\n\n\nOnce a \nProcessDescription\n is identified the \nvalidate(request, description)\n method is called to analyse the remaining request parameters. Again, a new \nCompositeOwsException\n object is created to collect any occurring exceptions. As next check, the parameters \nresponseMode\n and \noutput\n definition are extracted from \nExecuteRequest\n for investigation. If \nresponseMode\n is set to \n\"RAW\"\n, then only one single \noutput\n must be defined. If that condition is violated (e.g. none or more than one output is requested) than a \nInvalidParameterValueException\n for parameter \nresponseMode\n is added to \nCompositeOwsException\n.\n\n\nNext, the \ninput\n definitions of \nExecuteRequest\n are validated according to their individual \ninput description\n. This will be explained in section \nInput Validation in detail\n.\n\n\nSimilarly, the \noutput\n definitions of \nExecuteRequest\n are checked for validity according to their individual \noutput description\n. This is described in detail in section \nOutput Validation in detail\n.\n\n\nLast, the \ncardinalities\n of in- and outputs analysed, which is highlighted in section \nCardinality Validation in detail\n.\n\n\nIf any \nException\n has been created during the validation process (due to incorrect request parameters), it is collected within \nCompositeOwsException\n instances. Should they contain any \nException\n, they are ultimately thrown and validation fails. Otherwise (no error/exception occurred), validation succeeds and the actual processing of the \nExecuteRequest\n may continue.\n\n\nExecute Request Validation\n\n\nInput Validation in detail\n\n\nIn this section the validation of the \ninputs\n within an \nExecuteRequest\n is described as depicted in the following diagram. While the diagram repeats some general validation steps related to \ninputs\n, other steps are completely omitted.\n\n\nWith regard to \ninput\n validation, the \nProcessDescription\n as well as the \ninputs\n (where each input is represented by a single Java component \nProcessData\n) are required. The \nvalidateInputs()\n method takes both as arguments and first creates a \nCompositeOwsException\n to collect possible \nInvalidParameterValueExceptions\n.\n\n\nThen each \nProcessData\n input is validated individually within the method \nvalidateInput()\n. Its \ninputIdentifier\n is used to find the associated \nProcessInputDescription\n that e.g. holds definitions of allowed \nformats\n or restrictions like \nallowed input values\n. During validation, the \nProcessData\n input from the request is checked for compatibility with its formal description. If no associated \nProcessInputDescription\n can be found, an \nInvalidParameterValueException\n for the \ninput identifier\n is added to \nCompositeOwsException\n.\n\n\nAn \nExecute\n \ninput\n can be of three types, \nvalue input\n (value is directly provided within definition), \nreference input\n (input only defines an URI where the value can be obtained) or \ngroup data\n (for nested input definitions). Depending on its type, the validation of each \nProcessData\n input differs. As the continuing validation for each type comprises multiple sub-tasks, their description follows in separate diagrams below.\n\n\nFinally, the \nCompositeOwsException\n is inspected for any containing \nExceptions\n that have to be thrown.\n\n\nExecute Request - Input Validation\n\n\nGroup Input Validation\n\n\nIn the following, the validation of a \ngroup input\n within the method \nvalidateInputs()\n of \nExecuteParameterValidator\n is focused. A \ngroup input\n comprises multiple nested \ninput\n definitions. Hence, the \nProcessData\n is processed as \nGroupProcessData\n and also the \nProcessInputDescription\n has to be the description of a \ngroup input\n, which is checked by calling its method \nisGroup()\n. If that is false (input is group but description is not), then an \nInvalidParameterValueException\n for the input is added to \nCompositeOwsException\n. Otherwise, the \nlist of nested inputs\n is fetched from \nGroupProcessData\n and the \nProcessInputDescription\n is turned into a \nGroupInputDescription\n via \nasGroup()\n. Next, the method \nvalidateInputs()\n of \nExecuteParameterValidator\n is re-called with the \nlist\n of nested \nProcessData\n \ninputs\n and the \nGroupInputDescription\n as parameters. Again, each nested input may be of type \nvalue input\n, \nreference input\n or \ngroup input\n. Validation of the first two are described below.\n\n\nExecute Request - Validation of Input as Group\n\n\nReference Input Validation\n\n\nSubsequently, the validation of a \nreference input\n is demonstrated. The input should contain a \nURI\n to the resource containing the actual value and specify a valid \nformat\n for its value. The \nProcessData\n input is thus interpreted as \nReferenceProcessData\n. Within the \nvalidateInput()\n method a new \nCompositeOwsException\n is created to collect possible \nExceptions\n. Next, the \nURI\n is extracted from \nReferenceProcessData\n via \ngetURI()\n. If it is equal to \nNULL\n, an \nInvalidParameterValueException\n is added to \nCompositeOwsException\n. Otherwise the specified \nformat\n has to be validated within \nvalidateFormat()\n. As this comprises multiple sub-tasks, it is described together with the validation of \nValue Inputs\n below. After that, if \nCompositeOwsException\n contains any \nExceptions\n, then it is thrown.\n\n\nExecute Request - Validation of Input as Reference\n\n\nValue Input and Format Validation\n\n\nHere, the \nProcessData\n input is treated as a \nValueProcessData\n that directly contains the input value. The only validation required is the validation of the input \nformat\n within the method \nvalidateFormat()\n. The remaining steps are equal to \ngroup inputs\n or \nreferenceInputs\n and are omitted here.\n\n\nExecute Request - Validation of Input as Value\n\n\nThe following diagram finally presents the validation of the input \nformat\n. Again, at the top of the diagram, some necessary steps from previous validation steps are included to show the context of the \nvalidateFormat()\n method. However the description of these tasks is omitted here as it was already described before.\n\n\nThe explanation focuses the tasks of the \nvalidateFormat()\n method. First, the \nFormat\n is fetched from \nProcessData\n input. Two checks have to be performed to confirm validity of the \nFormat\n. First, it must not be \nempty()\n and second, its value must \nmatch a supported format\n of the selected process. To verify the latter, a new instance of \nInputFormatValidator\n is created using the \nProcessData\n as parameter. As an input may be of type \nliteral\n, \ncomplex\n, \nbounding box\n or \ngroup\n, it offers associated \nvisit()\n methods that take the \nProcessInputDescription\n as parameter to compare the Execute request input to its formal definition/description. Next, the method \nvisit()\n of \nProcessInputDescription\n is called with the \nInputFormatValidator\n as parameter. Depending on the input type it delegates the validation to the appropriate \nvisit()\n method of \nInputFormatValidator\n. There, all allowed/accepted formats for the current \nProcessData\n input are retrieved and compared to the \nFormat\n of the investigated input. If there is no match, the format specified by the Execute input is not accepted and hence an \nInvalidParameterValueException\n is added to \nCompositeOwsException\n. Otherwise, the input \nFormat\n is successfully validated.\n\n\nExecute Request - Validation of Input Format\n\n\nOutput Validation in detail\n\n\nThe process of validating the Execute request \noutput\n definitions is similar to the validation of request \ninputs\n. The first method calls again show, how the \nProcessDescription\n is fetched from the \nEngine\n with help of the \nprocess identifier\n extracted from the \nExecuteRequest\n. This section focuses the \nvalidateOutputs()\n method that takes the \nOutputDefinitions\n and \nProcessDescription\n as parameters. On the left side of the diagram, vertical grey bars indicate what task is performed at the associated method calls. So basically, \nOutputDefinitions\n are checked for duplicates and afterwards, their \nFormat\n definitions have to match a supported \nFormat\n for each output. The relevant steps are described in more detail as follows.\n\n\nFirst, a new instance of \nCompositeOwsException\n is created to collect later \nExceptions\n. Then the list of \nOutputDefinitions\n is checked for duplicates by comparing their \noutput identifiers\n. If the same output was delivered more than once, an \nInvalidParameterValueException\n is added to \nCompositeOwsException\n.\n\n\nAfterwards, each \nOutputDefinitions\n is validated individually. Its \noutput identifier\n is used to retrieve the associated \nProcessOutputDescription\n from \nProcessDescription\n. If no such description can be found then the requested output does not exist and an \nInvalidParameterValueException\n is added to \nCompositeOwsException\n. In general, an \nOutputDefinition\n may be a \ngroup output\n containing nested \nOutputDefinitions\n or a single \nOutputDefinition\n. If it is a \ngroup input\n then the whole validation process has to be redone for the nested outputs by re-calling \nvalidateOutputs()\n with the nested \nOutputDefinitions\n and the description as parameters. Otherwise, the single \nOutputDefinition\n is validated through verification of a matching \nFormat\n. As the process of validating an output \nFormat\n is more or less identical to the validation of an input \nFormat\n the description is omitted here. It was already described in the final paragraphs of section \nInput Validation in detail\n.\n\n\nExecute Request - Output Validation\n\n\nCardinality Validation in detail\n\n\nAs final step of validating an Execute request, the \ncardinalities of the inputs\n have to be checked. In general, each WPS process defines one or more inputs, each having a certain range of occurrences within a single Execute request specified by a \nminimum\n and \nmaximum\n number. At the same time, inputs might be mandatory or optional. E.g., a process to compute a buffer geometry requires a \"distance\" attribute and one ore more \"input geometries\" to buffer. While both inputs are mandatory (as the algorithm/process creates buffer geometries for each \"input geometry\" using the specified \"distance\"), a third optional input, let us name it \"annotation\", could be specified by the user in order to attach a text value as annotation for each created buffer geometry. However, in contrast to the mandatory inputs, the user may also leave this optional input out of the request.\n\n\nConcluding, the validation of \ninput cardinalities\n must verify two main conditions:\n\n\n\n\nCheck if the specified request inputs comply to their allowed range of occurrences.\n\n\nCheck if any mandatory/required input is missing within the request.\n\n\n\n\nThe \nProcessDescription\n objects holds the necessary \nProcessInputDescriptions\n to perform these verifications. Within the subsequent diagram, the necessary validation steps are depicted. The beginning method executions again show the context of the \nvalidateCardinalities()\n method and show, how required Java components are prepared.\n\n\nAs first step, like within all the other validations, a new instance of \nCompositeOwsException\n is created to collect any \nExceptions\n. Then two basic Java \nMap\n objects named \nCardinalities\n and \nOccurrences\n are computed (for simplicity, their computation has been omitted within the diagram). With respect to the \nCardinalities\n, each \nProcessData\n input from \nExecuteRequest\n is visited and its number of occurrences is counted. Thus, \nCardinalities\n maps the identifier of each \nrequest input\n to its factual number of occurrences. In contrast to that, \nOccurrences\n analyses the \nProcessInputDescription\n of each input defined for the WPS process and maps its identifier to a component named \nInputOccurrence\n, which represents the \nminimum\n and \nmaximum\n number of times this input may occur within a request. Summing it up, while \nCardinalities\n holds the factual number of occurrences for each input (the so-called \ncardinality\n), \nOccurrences\n stores the allowed number of occurrences.\n\n\nThe next step is to iterate over each entry of \nCardinalities\n and check if its \ncardinality\n is valid. For this reason, the associated \nInputOccurrence\n of \nOccurrences\n is retrieved (linked through the same map key \ninput identifier\n). Its method \nisInBounds()\n checks if the factual \ncardinality\n is within the range of allowed occurrences (between \nmin\n and \nmax\n) and return a boolean value. If the factual \ncardinality\n is out of bounds (\nisInBounds()\n return \nfalse\n) then an \nInvalidParameterValueException\n is added to \nCompositeOwsException\n.\n\n\nAs final validation, the code iterates over each entry of \nOccurrences\n in order to identify whether all required/mandatory inputs are defined within \nExecuteRequest\n. Each \nInputOccurrence\n object is checked if it \nisRequired()\n (its \nmin\n value is > 1). If so, the \nCardinalities\n map is checked to contain an entry with the same \ninput identifier\n as key. Should there be any missing mandatory input (\nCardinalities\n does not have a matching entry for the \ninput identifier\n), then a \nMissingParameterValueException\n is added to \nCompositeOwsException\n.\n\n\nIf any \nException\n has been added to \nCompositeOwsException\n during the validation process it is thrown. Otherwise validation succeeded with no errors.\n\n\nExecute Request - Validation of Input Cardinalities\n\n\nExecute - Detailed Request Handling\n\n\nTo concretize the handling and processing of an \nExecuteRequest\n, the \nhandle()\n method of the \nExecuteHandler\n is inspected in more detail:\n\n\n\n\nall necessary parameters are extracted from the \nExecuteRequest\n. This includes:\n\n\nservice\n: \"WPS\"\n\n\nversion\n: e.g. \"2.0.0\"\n\n\nprocess identifier\n: the identifier of the process to be executed\n\n\ninputs\n: the list of inputs for the selected process\n\n\noutputs\n: the list of outputs for the selected process\n\n\nresponse mode\n: either \n\"document\"\n to receive an \nExecuteResponse\n including a complete \nResultDocument\n according to the \nWPS standard\n or \n\"raw\"\n to request \none single\n raw output without a formal \nResultDocument\n structure.\n\n\nexecution mode\n: either \n\"async\"\n for an asynchronous execution, which will produce a \nExecuteResponse\n with an embedded \nstatus info\n document or \n\"sync\"\n for a synchronous execution that first completes execution of the process/job and then includes the computed \nresult(s)\n within the \nExecuteResponse\n.\n\n\n\n\n\n\nthe method \nexecute()\n of \nEngine\n is called with \nprocess identifier\n, \ninputs\n, \noutputs\n and \nresponse mode\n as parameters. This will cause the \nEngine\n to create a new \nJob\n instance to be executed. Its associated \njob identifier\n is returned to \nExecuteHandler\n.\n\n\ndepending on the parameter \nexecution mode\n (\"sync\" or \"async\"), the subsequent processing differs. Both cases are described subsequently:\n\n\ncase \nsync\n: in short, the processing waits for the \nJob\n to complete and retrieves the \nResult\n object that includes all computed \noutputs\n to return them along with the \nExecutionResponse\n. If in addition the parameter \nresponse mode\n is set to \nraw\n, then only one \noutput\n is extracted from the \nResult\n as instance of \nProcessData\n. From this \nProcessData\n \noutput\n the \ncontent/media type\n is extracted and set within the \nExecuteResponse\n, which is then returned.\n\n\ncase \nasync\n: in contrast to the previous case, \nJavaPS\n does not wait for the \nJob\n execution to complete. Instead, only the \nstatus\n of the \nJob\n is fetched via the \ngetStatus()\n method. It uses the parameter \njob identifier\n to locate the \nJob\n, from which its \nstatus\n is retrieved as \nStatusInfo\n. Afterwards the \nStatusInfo\n is embedded within the \nExecuteResponse\n and returned.\n\n\n\n\n\n\n\n\nExecute Workflow - handleRequest detailed\n\n\nTo complete the description of the \nExecute\n operation, the next diagram focuses the execution of a \nJob\n. In the previous diagram, this step was simplified and only showed that a \nJob\n instance was created, whose execution produces a \nResult\n object containing all requested \noutputs\n as \nProcessData\n. Hence, a more detailed description of the necessary processing steps is given below:\n\n\n\n\nwhen the \nEngine\n is called via the \nexecute()\n method, it first has to retrieve the \nIAlgorithm\n implementation that is associated to the \nprocess identifier\n. For this reason, it delegates the retrieval to the \nRepositoryManager\n that locates the \nAlgorithmRepository\n containing the \nIAlgorithm\n implementation for the \nprocess identifier\n.\n\n\nfrom the \nIAlgorithm\n implementation, its \nProcessDescription\n is used to decode the \ninputs\n as \nProcessInputs\n with the help of \nProcessInputDecoder\n. More information about the decoding of process inputs is provided in section \nBinding and Data Handlers for Data Representation/Transformation of Process In- and Outputs\n of a separate guide about \nAlgorithm definitions and the creation of an External Processing Repository\n.\n\n\nnext, the \nJobIdGenerator\n component is called to \ncreate()\n a new unique \njob identifier\n. Once done, a new \nJob\n instance is created as \nFuture\n object using the parameters \nalgorithm\n, \njob identifier\n, \ninputs\n, \noutputs\n and \nresponse mode\n.\n\n\nthe \nJob\n instance is \nsubmitted\n to the \nExecutorService\n, which is a component that manages and triggers job execution. As the \nJob\n is also a \nFuture\n object it can be queried for information such as its \nstatus\n at any time. Only the \nResult\n cannot be retrieved right away, since that has to be computed before. However, any \nFuture\n object offers a \nget()\n method, which will wait, if necessary, to complete the execution and then return the \nresult\n. The \nEngine\n now adds the \nJob\n to its class property maps \ncancelers\n and \njobs\n and return the \njob identifier\n to the \nExecuteHandler\n.\n\n\ndepending on the \nexecution strategy\n the \nExecutorService\n will \nrun()\n the execution of the \nJob\n eventually. The \nJob\n's \nstatus\n is updated to \nrunning\n and the \nIAlgorithm\n implementation is triggered to \nexecute()\n the process.\n\n\nIAlgorithm\n implementation performs the process-specific steps to compute the \noutputs\n. These \noutputs\n are then properly encoded with the help of \nProcessOutputEncoder\n and set as property \nnonPersistendResult\n of the \nJob\n. The \nJob\n's \nstatus\n is set to \nsucceeded\n. Of course, if any error occurred during process execution, then processing is aborted and the \nstatus\n is set to \nfailed\n instead.\n\n\nAfter successful job completion, the \nEngine\n is informed via \nonJobCompletion()\n to \nsave()\n the \nJob\n information including its \nstatus\n and \nresult\n (\noutputs\n), e.g. on the local hard drive of the server hosting the WPS. Here, the component \nResultPersistence\n is used to persist the information.\n\n\nthe \nEngine\n removes the \nJob\n from its class property maps \ncancelers\n and \njobs\n and retrieves the persisted \nResult\n from \nResultPersistence\n to return it to the \nJob\n.\n\n\nthe \nJob\n sets the \nResult\n and executes any \nlisteners\n that are registered for the event.\n\n\n\n\nExecute Workflow - Job Execution detailed\n\n\nGetStatus\n\n\nGetStatus - Basic Workflow\n\n\nThe aim of the \nGetStatus\n operation is to retrieve the current \nstatus\n of the \njob\n with the submitted \njob identifier\n. The following coarse workflow diagram shows an exemplar \nGetStatus GET\n request. The request is parsed by \nKvpBinding\n as a \nGetStatusRequest\n. Validation is performed by \nJobIdParameterValidator\n, which checks whether a parameter named \njobId\n exists whose value can be resolved to an existing \njob identifier\n within the WPS. Subsequently, the \nGetStatusHandler\n performs the actual request handling to retrieve the current \njob status\n and return it within a \nGetStatusResponse\n.\n\n\nGetStatus Workflow coarse\n\n\nGetStatus - Request Validation\n\n\nAs indicated in the lower diagram, the component \nJobIdParameterValidator\n performs validation of a \nGetStatus\n request object. In particular, it extracts the parameter \njobId\n from the request object and checks the following conditions:\n\n\n\n\njobId\n is a \nNULL\n object\n\n\nthe value of \njobId\n is a \nNULL\n object\n\n\nthe value of \njobId\n is an \nempty\n object\n\n\n\n\nIf any of these conditions is \ntrue\n, then a \nMissingParameterValueException\n is thrown, as the request does not specify a \njobId\n parameter value at all. Otherwise, the \njobId\n value specified within the request object is checked for validity. In particular, the \nEngine\n is asked whether it contains a \nJob\n instance associated to the \njobId\n. If not, an \nInvalidParameterValueException\n is thrown. When not exception was thrown, then the \njobId\n does point to an existing \nJob\n and validation was successful.\n\n\nGetStatus Request Validation\n\n\nGetStatus - Detailed Request Handling\n\n\nThe details of the \nhandle()\n method of the \nGetStatusHandler\n are demonstrated in the next diagram. The following sub-tasks are performed:\n\n\n\n\nFrom the \nGetStatusRequest\n object the parameters \nservice\n, \nversion\n and \njobId\n are extracted. The latter is an identifier pointing to the \nJob\n instance that has to be present within the \nWPS\n.\n\n\n\n\nThe method \ngetStatus()\n from \nEngine\n is called with \njobId\n as parameter. Depending on the existence of a \nJob\n instance with the specified \njobId\n within \nengineInstance.jobs\n, the workflow differs as described below. For one, the job might exist within the memory (e.g. when the job is currently executed or has only been \naccepted\n but is not running yet) and hence the \njob information\n can directly be retrieved from the \nJob\n instance. Otherwise the \njob information\n has already been persisted (e.g. because the job was finished) and hence has to be retrieved using \nResultPersistence\n, which retrieves the required information from the persisted resource.\n\n\n\n\nJob exists within engineInstance.jobs and thus exists in memory\n:\n\n\nthe method \ngetStatus()\n of the existing \nJob\n instance with identifier \njobId\n is called. Within this method, a new \nStatusInfo\n object is created and filled with relevant information like \njob identifier\n.\n\n\nfrom the \nJob\n instance, the \nJobStatus\n object can be retrieved, which contains the requested \nstatus information\n. It is used to set the \nstatus\n property within \nStatusInfo\n.\n\n\nDepending on the \nJobStatus\n, additional information has to be set within \nStatusInfo\n. If the \nJobStatus\n is \naccepted\n or \nrunning\n, then the properties \nestimatedCompletion\n (date of estimated completion of job), \npercentCompleted\n and \nnextPoll\n (information for clients when to re-request the status) are set. Else if the \nJobStatus\n is \nsucceeded\n or \nfailed\n, no additional information is added to \nStatusInfo\n. Actually, the code suggests that an \nexpiration date\n (indicated when the job information is deleted) has to be computed and set, but as of 12.12.2016 there is no implementation yet.\n\n\nthe \nStatusInfo\n object is then returned and forwarded to \nGetStatusHandler\n.\n\n\n\n\n\n\nJob information has been persisted\n:\n\n\nhere, the job has already finished and its information like \nstatus\n or \nresults\n have been previously persisted (e.g. as a JSON file). Hence, this information has to be retrieved from the persisted resource using \nResultPersistence\n. In consequence, its method \ngetStatus()\n is called using the \njobId\n as parameter.\n\n\nthe relevant \njob metadata\n and \nexpiration date\n are loaded from the persisted job resource via \ngetJobMetadata(jobId)\n and \ngetExpirationDate(jobId)\n.\n\n\na new instance of \nStatusInfo\n is created and instantiated with the parameters \njobId\n and \nexpiration date\n.\n\n\na new \nJobStatus\n object is created from \njob metadata\n and also set within \nStatusInfo\n.\n\n\nfinally, the \nStatusInfo\n instance is returned and forwarded to \nGetStatusHandler\n.\n\n\n\n\n\n\n\n\n\n\n\n\nA new \nGetStatusResponse\n is created using \nservice\n, \nversion\n and the retrieved \nstatusInfo\n as parameters. This response object is then returned.\n\n\n\n\n\n\nGetStatus - handleRequest detailed\n\n\nGetResult\n\n\nGetResult - Basic Workflow\n\n\nA \nGetResult\n operation is used to retrieve the \nresult(s)\n of the \njob\n with the submitted \njob identifier\n. The following coarse workflow diagram shows an exemplar \nGetResult GET\n request. The request is parsed by \nKvpBinding\n as a \nGetResultRequest\n and validation is performed by \nJobIdParameterValidator\n, which checks whether the parameter \njobId\n points to an existing \njob identifier\n within the WPS. If so, the \nGetResultHandler\n performs the actual request handling and returns the requested \noutput(s)/result(s)\n within a \nGetResultResponse\n.\n\n\nGetResult Workflow coarse\n\n\nGetResult - Request Validation\n\n\nSimilar to the validation of a \nGetStatus\n request, the component \nJobIdParameterValidator\n performs validation of a \nGetResult\n request object. Thus, the validation workflow is identical as already described in section \nvalidation of GetStatus request\n.\n\n\nGetResult Request Validation\n\n\nGetResult - Detailed Request Handling\n\n\nSimilar to the previous operation descriptions, the following diagram focuses the \nhandle()\n method of \nGetResultHandler\n. In general, the required information is stored within the associated \nJob\n object, which may or may not have been persisted. If it has not yet been persisted, the result can simply be retrieved from the associated \nJob\n instance. Otherwise, the information has to be loaded from the persisted resource and the \nResult\n object has to be constructed from the scratch. Subsequently, both cases are described in detail. The \nhandle()\n method comprises the following sub-tasks:\n\n\n\n\nThe parameters \nservice\n, \nversion\n and \njobId\n are extracted from the \nGetResultRequest\n object. The \njobId\n is an identifier pointing to the \nJob\n instance that has to be present within the \nWPS\n.\n\n\n\n\nThe method \ngetResult()\n from \nEngine\n is called with \njobId\n as parameter. Depending on the existence of a \nJob\n instance with the specified \njobId\n within \nengineInstance.jobs\n, the workflow differs as described below. For one, the job might exist within the memory (e.g. when the job is currently executed or has only been \naccepted\n but is not running yet) and hence the \njob information\n containing the \nResult\n can directly be retrieved from the \nJob\n instance. Otherwise the \njob information\n has already been persisted (e.g. because the job was finished) and hence has to be retrieved using \nResultPersistence\n, which retrieves the required information from the persisted resource. Bot cases are highlighted in the following:\n\n\n\n\nJob exists within engineInstance.jobs and thus exists in memory\n:\n\n\nthe \nJob\n object contains the \nResult\n object or, if the job is not yet finished, will compute it to guarantee its existence. Since the \nJob\n instance can directly be fetched from \nEngine\n, it is simply returned, as it contains the \nResult\n.\n\n\n\n\n\n\nJob information has been persisted after Job finished (succeeded or failed)\n:\n\n\nhere, the \njob information\n was previously persisted and thus has to be reloaded from the associated resource (e.g. a JSON file). Hence, the \ngetResult()\n method of \nResultPersistence\n is called with the \njobId\n as parameter to refer to the right \nJob\n.\n\n\nResultPersistence\n now creates a new instance of \nResult\n, which is subsequently instantiated with the relevant information from the persisted \nJob\n resource. First, the \njobId\n is set.\n\n\nResultPersistence\n loads the \njob metadata\n from the persisted resource and sets the following properties within the created \nResult\n object: \nexpirationDate\n (date when the \nJob\n will permanently be deleted by the \nWPS\n), \nresponseMode\n (possible values are either \ndocument\n for a formal response document or \nraw\n to request a single \nraw output\n without surrounding response document), \njobStatus\n (possible values may be \nsucceeded\n or \nfailed\n according to \nWPS specification\n)\n\n\nif \njobStatus\n equals \nfailed\n, then the job execution was not successful. Hence, the \nerrorMessage\n property is extracted from \njob metadata\n and used to throw a suitable \nException\n.\n\n\notherwise (the job was executed without errors and \njobStatus\n equals \nsucceeded\n), the computed outputs of the \nJob\n have to be extracted and set within the \nResult\n object. For that reason, the property \noutputNodes\n is extracted from \njob metadata\n. Then a loop over each \noutputNode\n of \noutputNodes\n decodes the output information and creates a \nProcessData\n instance for each \noutputNode\n. Depending on the \noutput type\n (possible types are \nliteral\n, \ncomplex\n or \nboundingBox\n according to \nWPS specification\n) and \ntransmissionMode\n (possible modes are \nvalue\n or \nreference\n according to \nWPS specification\n) the \nProcessData\n may represent a \nvalue\n output, a \nreference\n output or a \ngroup data\n output.\n\n\nafter each \nProcessData\n output is set within \nResult\n it is returned to \nGetResultHandler\n.\n\n\n\n\n\n\n\n\n\n\n\n\nGetResultHandler\n creates a new instance of \nGetResultResponse\n using \nservice\n, \nversion\n and \nresult\n as parameters and returns it.\n\n\n\n\n\n\nGetResult - handleRequest detailed\n\n\nDismiss\n\n\nDismiss - Basic Workflow\n\n\nThe \nDismiss\n operation is used to cancel an \naccepted\n or \nrunning\n \njob\n. A \nDismiss\n GET request is parsed by \nKvpBinding\n as a \nDismissRequest\n. Validation is performed by \nJobIdParameterValidator\n that checks whether a parameter named \njobId\n exists and whether its value can be resolved to an existing \njob identifier\n within the WPS. Subsequently, the \nDismissHandler\n processes the request to cancel the specified job if possible and returns a \nDismissResponse\n, which includes the jobs \nStatus Info\n document.\n\n\nDismiss Workflow coarse\n\n\nDismiss - Request Validation\n\n\nSimilar to the validation of a \nGetStatus\n and \nGetResult\n request, the component \nJobIdParameterValidator\n performs validation of a \nDismiss\n request object. Thus, the validation workflow is identical as already described in section \nvalidation of GetStatus request\n.\n\n\nDismiss Request Validation\n\n\nDismiss - Detailed Request Handling\n\n\nAgain, more detailed information about the sub-tasks within the \nhandle()\n method of \nDismissHandler\n are explained in the following:\n\n\n\n\nthe necessary parameters of the \nDismissRequest\n are extracted, including \nservice\n (\"WPS\"), \nversion\n (e.g. \"2.0.0\") and \njobId\n.\n\n\nafter that the \nEngine\n is informed to \ndismiss()\n the job with the extracted \njobId\n. For this reason, the \nEngine\n retrieves the \nJob\n and at the same checks whether the job is available as \nCancelable\n. Here, it has to be considered that the \nEngine\n manages jobs within multiple class properties, for one the \nJob\n instances within a \nConcurrentHashMap\n and, if their job execution is not yet finished, also as \nCancelable\n within a second \nConcurrentHashMap\n. On completed job execution, the job is removed from the cancelable map.\n\n\nin consequence, if a job is available as \nCancelable\n, then its \ncancel()\n method is called to abort its execution. A \nboolean\n value indicates whether this event was successful. The subsequent section shows an \nprocess algorithm example\n to clarify how an accepted or running job is \ndismissed\n.\n\n\nthe \nJobStatus\n of the \nJob\n instance with identifier \njobId\n is retrieved and forwarded to the \nDismissHandler\n.\n\n\nfinally, a new \nDismissResponse\n instance is created from \nservice\n (\"WPS\"), \nversion\n (e.g. \"2.0.0\") and \nJobStatus\n. Hence the response object contains the \nstatus info\n document of the dismissed job.\n\n\n\n\nDismiss - handleRequest detailed\n\n\nCancelling an accepted or running Job via Dismiss - an Example from the Developer Perspective\n\n\nCancelling a \njob\n before it completes its computation is a key aspect of the \nWPS specification\n. As shown in the previous section, the \nDismiss\n operation triggers the WPS server to \ncancel()\n the execution of a certain \nJob\n.\n\n\nAs explained in section \nExecute - Detailed Request Handling\n, when a \nJob\n is submitted to the \nExecutorService\n that manages process/algorithm execution, a \nFuture\n object is created and added as \nCancelable\n to the \nEngines\n property \nengine.cancelers\n. A \nFuture\n object comprises the method \ncancel()\n, which prevents the \nFuture\n from executing if not already run or interrupts it if currently running. To be precise, if the execution has not started yet, a call to the \ncancel()\n method prevents the process from starting at all. When the process is already being executed, the \ncancel()\n method interrupts the thread, in which the \nFuture\n is executed (compare \nOracle Java Doc of Future\n). However, interrupting the thread \ndoes not stop the execution directly\n. Instead the developer of the process/algorithm code explicitly has to consider the \ninterrupt state\n and check it manually in order to abort the execution.\n\n\nE.g. the following Java code shows an example of an execute method that computes buffer geometries for a list of input geometries. Note that the definition of an \nAlgorithm\n for \nJavaPS\n is explained in section \nHow to add new Processes/Algorithms\n and thus not explained here. What is important to know is that in- and outputs of an \nAlgorithm\n are stored as Java properties of the implementing class. Within a method annotated by \n@Execute\n the computation that is called when executing the associated \nJob\n is implemented. The code below only shows that method. The computation of all the buffer geometries is done within a for-loop that iterates over all input geometries. Within each iteration, the condition \nif (Thread.currentThread().isInterrupted())\n is called to check whether the thread has been interrupted. If so, then the computation should be aborted, e.g. by the simple statement \nreturn\n.\n\n\n\n@Execute\n/**\n * This is an exemplary job execution to show how the\n * \"Dismiss\" operation works and what a Developer has\n * to have in mind when implementing the process\n * execution method\n */\npublic void computeBuffer_dismissable() {\n\n    /*\n     * inputGeometries might be a huge number of geometries\n     * for which a buffer shall be computed\n     */\n    List<Geometry> inputGeometries = this.data;\n    double radius = this.radius;\n\n    List<Geometry> bufferedGeometries = new ArrayList<Geometry>(inputGeometries.size());\n\n    for (Geometry geometry : inputGeometries) {\n\n        /*\n         * before computing the buffer for the current geometry\n         * check if the current thread was interrupted\n         *\n         * if so, then we must manually exit the computation and return!\n         */\n        if (Thread.currentThread().isInterrupted())\n            return;\n\n        /*\n         * else continue computation\n         */\n        else{\n            Geometry buffer = geometry.buffer(radius);\n            bufferedGeometries.add(buffer);\n        }\n}\n\n        /*\n         * computation was successful and we set the output-property\n         * with the computed buffered geometries\n         */\n        this.bufferedOutput = bufferedGeometries;\n    }\n\n\n\n\n\nHence, as a developer, you have to take care of properly quitting a running process in case the computation is \ncancelled\n via a \nDismiss\n request. To do so, you have to check \nif (Thread.currentThread().isInterrupted())\n where applicable. Otherwise, the execution would finish as the \nFutures\n \ncancel()\n method cannot stop it directly.",
            "title": "Workflow Descriptions of WPS Operations"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#javaps-documentation-workflow-of-wps-20-operations",
            "text": "",
            "title": "JavaPS Documentation - Workflow of WPS 2.0 Operations"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#workflow-of-wps-200-operations",
            "text": "Within the following sections the workflow of each operation of the WPS 2.0.0 standard that is supported by  JavaPS  is introduced in detail. Each description begins with a  coarse workflow  overview of the operation, then focuses  request validation  and finally presents the  request handling  in detail. With regard to the  request validation ,  JavaPS  only comprises validating components that check each request object for WPS specific parameters. As  Iceland  is a generic service infrastructure for numerous OCG Web services, it also performs the basic check of the standard parameters  \"service\" ,  \"version\"  and  \"request\" . In particular, the value of the  \"request\"  parameter indicates, which WPS operation is requested and thus which  ValidationHandler  and  OperationHandler  components are used. In the following, the operations  GetCapabilities ,  DescribeProcess ,  Execute ,  GetStatus ,  GetResult  and  Dismiss  are focused.  Throughout all sequence diagrams the UML sequence diagram notation is used. In addition, the colours ( blue  and  red ) of the participating application components indicate their membership within either  JavaPS  or  Iceland . While  blue  components belong to  Iceland ,  red  components are offered by  JavaPS .",
            "title": "Workflow of WPS 2.0.0 Operations"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#getcapabilities",
            "text": "",
            "title": "GetCapabilities"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#getcapabilities-basic-workflow",
            "text": "Within the  GetCapabilities  operation the service capabilities of the WPS instance are retrieved. The subsequent diagram shows the coarse workflow between the participating system components for a  GetCapabilities GET  request.  JavaPS  uses  KvpBinding  to parse the request as a  GetCapabilitiesRequest , validates the request with the help of  GetCapabilitiesParameterValidator  and request handling is done by  GetCapabilitiesHandler . The latter returns a  GetCapabilitiesResponse  object including the retrieved capabilities.  GetCapabilities Workflow coarse",
            "title": "GetCapabilities - Basic Workflow"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#getcapabilities-request-validation",
            "text": "As of January 2017 there is no validation code for  GetGapabilities  operation.",
            "title": "GetCapabilities - Request Validation"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#getcapabilities-detailed-request-handling",
            "text": "To highlight the request handling workflow the subsequent diagram focuses only the  handle()  method of the  GetCapabilitiesHandler . To increase response time of  GetCapabilities  requests against the WPS,  Iceland  and  JavaPS  make use of a caching mechanism that holds the capabilities information within the memory for rapid access. Hereby, the capabilities information is extracted from the actual data source from time to time to keep the cached data up to date. When answering a  GetCapabilities  request, the data is directly read from the cached information and used to create the response object without accessing the actual data source.  The main tasks of the  GetCapabilities  request handling are:   use the  GetCapabilitiesRequest  object to create a  GetCapabilitiesResponse  object and set basic information about  service  (\"WPS\") and  version  (e.g. \"2.0.0\").  then inspect the  GetCapabilitiesRequest  object for the requested  sections  (filter for contents) and  locale  (language). Available sections are:  ServiceIdentification  - information about the WPS itself  ServiceProvider  - information about the provider offering the WPS  OperationsMetadata  - information about the supported operations and bindings  Languages/Locales  - information about available languages  Contents  - information about processes offered by the WPS    for each of the above listed Capabilities sections the application inspects whether it is requested, and if so, extracts that information from the cached data. The sections  ServiceIdentification ,  ServiceProvider  and  Languages/Locales  are stored within the  ServiceMetadataRepository . The  OperationsMetadata  is extracted from the  RequestOperatorRepository  and the available processes are extracted from the  Engine . The  Engine  is a central component of  JavaPS  to manage jobs and processes and control their execution as well as persistence of job results. Each available process is represented by an instance of  ProcessOffering . The available processes are returned as  Set\\<ProcessOffering> , from which a new instance of  ProcessOfferings  is created.  as  Iceland  is a generic abstract framework for arbitrary OGC Web services it offers the component  OwsCapabilities  to include common  Capabilities  information. Hence an instance of  OwsCapabilities  is created from all requested section objects except the WPS specific  ProcessOfferings .  finally, a new instance of  WPSCapabilities  is created from  OwsCapabilities  and  ProcessOfferings , which is set within the  GetCapabilitiesResponse  and returned.   GetCapabilities Workflow - handleRequest detailed",
            "title": "GetCapabilities - Detailed Request Handling"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#describeprocess",
            "text": "",
            "title": "DescribeProcess"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#describeprocess-basic-workflow",
            "text": "The  DescribeProcess  Operation is used by clients to retrieve the  process description  of a certain WPS process. The subsequent diagram shows the coarse workflow between the participating system components for a  DescribeProcess GET  request.  JavaPS  uses  KvpBinding  to parse the request as a  DescribeProcessRequest , validates the request with the help of  DescribeProcessParameterValidator  and request handling is done by  DescribeProcessHandler . The latter returns a  DescribeProcessResponse  object including the requested  process description .  DescribeProcess Workflow coarse",
            "title": "DescribeProcess - Basic Workflow"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#describeprocess-request-validation",
            "text": "Validation of a  DescribeProcess  request is done by  DescribeProcessParameterValidator  and visualized in the diagram at the end of this section. Basically, a request has to contain the parameter  \"identifier\" . Its value might be a reference to a single identifier of the associated process or a list of references to multiple processes or it may be the word  \"ALL\"  to request all process descriptions from the WPS. Hence, during validation, the  DescribeProcessRequest  object is analyzed for the existence of the required parameter. If it does not exist or is an empty value, a  MissingParameterValueException  is immediately thrown. Otherwise, each individual parameter value has to be checked. Before that an empty  CompositeOwsException  is created, which is used to collect any  exception  that might occur when checking each  identifier value . Validating a single  identifier value  is split in two checks. First, if the  identifier value  is a  NULL  object, then a  MissingParameterValueException  is added to  CompositeOwsException . Second, the  parameter value  must reference an existing  process  within the WPS instance. To verify this, the  Engine  component is asked whether it contains an associated  process description . If not, an  InvalidParameterValueException  is added to  CompositeOwsException . Finally, as soon as each identifier has been checked, the  CompositeOwsException  object is analyzed. If it contains any  exception , it is thrown as the request contained invalid or missing parameter values. If it empty, then validation was successful and the actual operation handling can be continued.  DescribeProcess Request Validation  As indicated by the notes within the diagram, the upper description of the validation process have been simplified. Actually, Java Lambda expressions and  Optional  objects are used when creating an  Exception  first that are afterwards investigated to transfer any  Exception  to  CompositeOwsException . For reasons of simplicity, the sequence diagram displays these steps in a different way.",
            "title": "DescribeProcess - Request Validation"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#describeprocess-detailed-request-handling",
            "text": "The subsequent diagram highlights the request handling of the  DescribeProcess  request. Basically, the  process identifier  is extracted from the  DescribeProcessRequest  and used to acquire the associated  process description  as  ProcessOffering .  JavaPS  organises available processes as child classes of interface  IAlgorithm . Hence, a  process  is an  IAlgorithm  that has a  process description  as property and an  execute()  method to run the algorithm.  In more detail, the following tasks are performed:   extract  process identifier  from  DescribeProcessRequest  call  getProcessDescription()  method from  Engine . Within this method, the  Engine  contacts the  RepositoryManager  to find a suitable  AlgorithmRepository , from which the  ProcessDescription  is retrieved.  an instance of  ProcessOffering  is created using the  ProcessDescription  as parameter.  eventually a  DescribeProcessResponse  object is created from  service  (\"WPS\") and  version  (e.g. \"2.0.0\") and the  ProcessOffering  and returned.   DescribeProcess - handleRequest detailed",
            "title": "DescribeProcess - Detailed Request Handling"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#execute",
            "text": "",
            "title": "Execute"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#execute-basic-workflow",
            "text": "In contrast to the previous WPS  GET  operations examples, the  Execute  operation is demonstrated using HTTP  POST  and  POX  binding. With regard to the coarse workflow, the  PoxBinding  component parses the request as  ExecuteRequest  within the  doPostOperation()  method. The request is validated by  ExecuteParameterValidator , which performs a lot more checks compared to all other WPS operations as explained below. After validation, the  ExecuteHandler  processes the request and returns an  ExecuteResponse . In short, a new  Job  instance is created that is executed synchronously or asynchronously. While in the first case (synchronous execution), the response contains the computed  result(s) , the latter case includes a  status info  document within the response.  Execute Workflow coarse",
            "title": "Execute - Basic Workflow"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#execute-request-validation",
            "text": "Validation of an  Execute  requires much more steps compared to all other WPS operations. An  Execute  request comprises the following parameters:   identifier : the identifier of the process to be executed  input : one or more input definitions as process inputs. Hereby, inputs may be mandatory or optional and their cardinality (minimum and maximum occurrences) may be different. Also an input is defined using a certain format. The input value can be specified directly or might be given as a reference to a resource that must be fetched by the WPS first.  output : one or more output definitions as process outputs. Similar to the input definition, outputs may be mandatory or optional, uses a certain format and can be offered as value or as reference (URL to external resource).  mode : the execution mode, whose value indicates  synchronous  or  asynchronous  process execution.  response : the response format, whose value indicates whether outputs shall be encoded as formal  response document  or as  raw output .   In short, the validation of an  Execute  request comprises the following checks:   validation of  process identifier : is it missing or does it address a non-existent process?  validation of  response mode  in combination with requested outputs: if it is set to  RAW , then only one single output can be requested.  validation of  inputs : does  input identifier  point to an existing  input  of the selected process? Is the  input  content defined correctly with regard to its description?  validation of  outputs : does  output identifier  point to an existing  output  of the selected process? Is the  output  content defined correctly with regard to its description?  validation of  cardinalities : in general a process might require certain mandatory inputs. Also a process may restrict the number of certain inputs to a lower and upper boundary. Hence this check looks for missing mandatory inputs and inspects the numbers of included inputs.   The following sequence diagrams and sub-sections visualize these main steps. First a coarse overview is presented. Afterwards the validations of  inputs ,  outputs  and  cardinalities  are focused in more detail separately.",
            "title": "Execute - Request Validation"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#coarse-overview-of-execute-request-validation",
            "text": "Validation is performed by  ExecuteParameterValidator . Each individual step of the validation process may cause a certain  Exception . Thus, as first step, a generic  CompositeOwsException  object is created, which is supposed to hold one ore multiple occurring  Exceptions  to throw them as a composed object.  Then the  process identifier  is extracted from the  ExecuteRequest . If it is missing, then a  MissingParameterValueException  for parameter  identifier  is created and added to  CompositeOwsException . Afterwards, the  Engine  component is used to retrieve the  ProcessDescription  associated to the  process identifier . If not description object can be found, an  InvalidParameterValueException  for parameter  identifier  is created as the identifier does not point to an existing process within the  WPS .  Once a  ProcessDescription  is identified the  validate(request, description)  method is called to analyse the remaining request parameters. Again, a new  CompositeOwsException  object is created to collect any occurring exceptions. As next check, the parameters  responseMode  and  output  definition are extracted from  ExecuteRequest  for investigation. If  responseMode  is set to  \"RAW\" , then only one single  output  must be defined. If that condition is violated (e.g. none or more than one output is requested) than a  InvalidParameterValueException  for parameter  responseMode  is added to  CompositeOwsException .  Next, the  input  definitions of  ExecuteRequest  are validated according to their individual  input description . This will be explained in section  Input Validation in detail .  Similarly, the  output  definitions of  ExecuteRequest  are checked for validity according to their individual  output description . This is described in detail in section  Output Validation in detail .  Last, the  cardinalities  of in- and outputs analysed, which is highlighted in section  Cardinality Validation in detail .  If any  Exception  has been created during the validation process (due to incorrect request parameters), it is collected within  CompositeOwsException  instances. Should they contain any  Exception , they are ultimately thrown and validation fails. Otherwise (no error/exception occurred), validation succeeds and the actual processing of the  ExecuteRequest  may continue.  Execute Request Validation",
            "title": "Coarse Overview of Execute Request Validation"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#input-validation-in-detail",
            "text": "In this section the validation of the  inputs  within an  ExecuteRequest  is described as depicted in the following diagram. While the diagram repeats some general validation steps related to  inputs , other steps are completely omitted.  With regard to  input  validation, the  ProcessDescription  as well as the  inputs  (where each input is represented by a single Java component  ProcessData ) are required. The  validateInputs()  method takes both as arguments and first creates a  CompositeOwsException  to collect possible  InvalidParameterValueExceptions .  Then each  ProcessData  input is validated individually within the method  validateInput() . Its  inputIdentifier  is used to find the associated  ProcessInputDescription  that e.g. holds definitions of allowed  formats  or restrictions like  allowed input values . During validation, the  ProcessData  input from the request is checked for compatibility with its formal description. If no associated  ProcessInputDescription  can be found, an  InvalidParameterValueException  for the  input identifier  is added to  CompositeOwsException .  An  Execute   input  can be of three types,  value input  (value is directly provided within definition),  reference input  (input only defines an URI where the value can be obtained) or  group data  (for nested input definitions). Depending on its type, the validation of each  ProcessData  input differs. As the continuing validation for each type comprises multiple sub-tasks, their description follows in separate diagrams below.  Finally, the  CompositeOwsException  is inspected for any containing  Exceptions  that have to be thrown.  Execute Request - Input Validation",
            "title": "Input Validation in detail"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#group-input-validation",
            "text": "In the following, the validation of a  group input  within the method  validateInputs()  of  ExecuteParameterValidator  is focused. A  group input  comprises multiple nested  input  definitions. Hence, the  ProcessData  is processed as  GroupProcessData  and also the  ProcessInputDescription  has to be the description of a  group input , which is checked by calling its method  isGroup() . If that is false (input is group but description is not), then an  InvalidParameterValueException  for the input is added to  CompositeOwsException . Otherwise, the  list of nested inputs  is fetched from  GroupProcessData  and the  ProcessInputDescription  is turned into a  GroupInputDescription  via  asGroup() . Next, the method  validateInputs()  of  ExecuteParameterValidator  is re-called with the  list  of nested  ProcessData   inputs  and the  GroupInputDescription  as parameters. Again, each nested input may be of type  value input ,  reference input  or  group input . Validation of the first two are described below.  Execute Request - Validation of Input as Group",
            "title": "Group Input Validation"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#reference-input-validation",
            "text": "Subsequently, the validation of a  reference input  is demonstrated. The input should contain a  URI  to the resource containing the actual value and specify a valid  format  for its value. The  ProcessData  input is thus interpreted as  ReferenceProcessData . Within the  validateInput()  method a new  CompositeOwsException  is created to collect possible  Exceptions . Next, the  URI  is extracted from  ReferenceProcessData  via  getURI() . If it is equal to  NULL , an  InvalidParameterValueException  is added to  CompositeOwsException . Otherwise the specified  format  has to be validated within  validateFormat() . As this comprises multiple sub-tasks, it is described together with the validation of  Value Inputs  below. After that, if  CompositeOwsException  contains any  Exceptions , then it is thrown.  Execute Request - Validation of Input as Reference",
            "title": "Reference Input Validation"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#value-input-and-format-validation",
            "text": "Here, the  ProcessData  input is treated as a  ValueProcessData  that directly contains the input value. The only validation required is the validation of the input  format  within the method  validateFormat() . The remaining steps are equal to  group inputs  or  referenceInputs  and are omitted here.  Execute Request - Validation of Input as Value  The following diagram finally presents the validation of the input  format . Again, at the top of the diagram, some necessary steps from previous validation steps are included to show the context of the  validateFormat()  method. However the description of these tasks is omitted here as it was already described before.  The explanation focuses the tasks of the  validateFormat()  method. First, the  Format  is fetched from  ProcessData  input. Two checks have to be performed to confirm validity of the  Format . First, it must not be  empty()  and second, its value must  match a supported format  of the selected process. To verify the latter, a new instance of  InputFormatValidator  is created using the  ProcessData  as parameter. As an input may be of type  literal ,  complex ,  bounding box  or  group , it offers associated  visit()  methods that take the  ProcessInputDescription  as parameter to compare the Execute request input to its formal definition/description. Next, the method  visit()  of  ProcessInputDescription  is called with the  InputFormatValidator  as parameter. Depending on the input type it delegates the validation to the appropriate  visit()  method of  InputFormatValidator . There, all allowed/accepted formats for the current  ProcessData  input are retrieved and compared to the  Format  of the investigated input. If there is no match, the format specified by the Execute input is not accepted and hence an  InvalidParameterValueException  is added to  CompositeOwsException . Otherwise, the input  Format  is successfully validated.  Execute Request - Validation of Input Format",
            "title": "Value Input and Format Validation"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#output-validation-in-detail",
            "text": "The process of validating the Execute request  output  definitions is similar to the validation of request  inputs . The first method calls again show, how the  ProcessDescription  is fetched from the  Engine  with help of the  process identifier  extracted from the  ExecuteRequest . This section focuses the  validateOutputs()  method that takes the  OutputDefinitions  and  ProcessDescription  as parameters. On the left side of the diagram, vertical grey bars indicate what task is performed at the associated method calls. So basically,  OutputDefinitions  are checked for duplicates and afterwards, their  Format  definitions have to match a supported  Format  for each output. The relevant steps are described in more detail as follows.  First, a new instance of  CompositeOwsException  is created to collect later  Exceptions . Then the list of  OutputDefinitions  is checked for duplicates by comparing their  output identifiers . If the same output was delivered more than once, an  InvalidParameterValueException  is added to  CompositeOwsException .  Afterwards, each  OutputDefinitions  is validated individually. Its  output identifier  is used to retrieve the associated  ProcessOutputDescription  from  ProcessDescription . If no such description can be found then the requested output does not exist and an  InvalidParameterValueException  is added to  CompositeOwsException . In general, an  OutputDefinition  may be a  group output  containing nested  OutputDefinitions  or a single  OutputDefinition . If it is a  group input  then the whole validation process has to be redone for the nested outputs by re-calling  validateOutputs()  with the nested  OutputDefinitions  and the description as parameters. Otherwise, the single  OutputDefinition  is validated through verification of a matching  Format . As the process of validating an output  Format  is more or less identical to the validation of an input  Format  the description is omitted here. It was already described in the final paragraphs of section  Input Validation in detail .  Execute Request - Output Validation",
            "title": "Output Validation in detail"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#cardinality-validation-in-detail",
            "text": "As final step of validating an Execute request, the  cardinalities of the inputs  have to be checked. In general, each WPS process defines one or more inputs, each having a certain range of occurrences within a single Execute request specified by a  minimum  and  maximum  number. At the same time, inputs might be mandatory or optional. E.g., a process to compute a buffer geometry requires a \"distance\" attribute and one ore more \"input geometries\" to buffer. While both inputs are mandatory (as the algorithm/process creates buffer geometries for each \"input geometry\" using the specified \"distance\"), a third optional input, let us name it \"annotation\", could be specified by the user in order to attach a text value as annotation for each created buffer geometry. However, in contrast to the mandatory inputs, the user may also leave this optional input out of the request.  Concluding, the validation of  input cardinalities  must verify two main conditions:   Check if the specified request inputs comply to their allowed range of occurrences.  Check if any mandatory/required input is missing within the request.   The  ProcessDescription  objects holds the necessary  ProcessInputDescriptions  to perform these verifications. Within the subsequent diagram, the necessary validation steps are depicted. The beginning method executions again show the context of the  validateCardinalities()  method and show, how required Java components are prepared.  As first step, like within all the other validations, a new instance of  CompositeOwsException  is created to collect any  Exceptions . Then two basic Java  Map  objects named  Cardinalities  and  Occurrences  are computed (for simplicity, their computation has been omitted within the diagram). With respect to the  Cardinalities , each  ProcessData  input from  ExecuteRequest  is visited and its number of occurrences is counted. Thus,  Cardinalities  maps the identifier of each  request input  to its factual number of occurrences. In contrast to that,  Occurrences  analyses the  ProcessInputDescription  of each input defined for the WPS process and maps its identifier to a component named  InputOccurrence , which represents the  minimum  and  maximum  number of times this input may occur within a request. Summing it up, while  Cardinalities  holds the factual number of occurrences for each input (the so-called  cardinality ),  Occurrences  stores the allowed number of occurrences.  The next step is to iterate over each entry of  Cardinalities  and check if its  cardinality  is valid. For this reason, the associated  InputOccurrence  of  Occurrences  is retrieved (linked through the same map key  input identifier ). Its method  isInBounds()  checks if the factual  cardinality  is within the range of allowed occurrences (between  min  and  max ) and return a boolean value. If the factual  cardinality  is out of bounds ( isInBounds()  return  false ) then an  InvalidParameterValueException  is added to  CompositeOwsException .  As final validation, the code iterates over each entry of  Occurrences  in order to identify whether all required/mandatory inputs are defined within  ExecuteRequest . Each  InputOccurrence  object is checked if it  isRequired()  (its  min  value is > 1). If so, the  Cardinalities  map is checked to contain an entry with the same  input identifier  as key. Should there be any missing mandatory input ( Cardinalities  does not have a matching entry for the  input identifier ), then a  MissingParameterValueException  is added to  CompositeOwsException .  If any  Exception  has been added to  CompositeOwsException  during the validation process it is thrown. Otherwise validation succeeded with no errors.  Execute Request - Validation of Input Cardinalities",
            "title": "Cardinality Validation in detail"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#execute-detailed-request-handling",
            "text": "To concretize the handling and processing of an  ExecuteRequest , the  handle()  method of the  ExecuteHandler  is inspected in more detail:   all necessary parameters are extracted from the  ExecuteRequest . This includes:  service : \"WPS\"  version : e.g. \"2.0.0\"  process identifier : the identifier of the process to be executed  inputs : the list of inputs for the selected process  outputs : the list of outputs for the selected process  response mode : either  \"document\"  to receive an  ExecuteResponse  including a complete  ResultDocument  according to the  WPS standard  or  \"raw\"  to request  one single  raw output without a formal  ResultDocument  structure.  execution mode : either  \"async\"  for an asynchronous execution, which will produce a  ExecuteResponse  with an embedded  status info  document or  \"sync\"  for a synchronous execution that first completes execution of the process/job and then includes the computed  result(s)  within the  ExecuteResponse .    the method  execute()  of  Engine  is called with  process identifier ,  inputs ,  outputs  and  response mode  as parameters. This will cause the  Engine  to create a new  Job  instance to be executed. Its associated  job identifier  is returned to  ExecuteHandler .  depending on the parameter  execution mode  (\"sync\" or \"async\"), the subsequent processing differs. Both cases are described subsequently:  case  sync : in short, the processing waits for the  Job  to complete and retrieves the  Result  object that includes all computed  outputs  to return them along with the  ExecutionResponse . If in addition the parameter  response mode  is set to  raw , then only one  output  is extracted from the  Result  as instance of  ProcessData . From this  ProcessData   output  the  content/media type  is extracted and set within the  ExecuteResponse , which is then returned.  case  async : in contrast to the previous case,  JavaPS  does not wait for the  Job  execution to complete. Instead, only the  status  of the  Job  is fetched via the  getStatus()  method. It uses the parameter  job identifier  to locate the  Job , from which its  status  is retrieved as  StatusInfo . Afterwards the  StatusInfo  is embedded within the  ExecuteResponse  and returned.     Execute Workflow - handleRequest detailed  To complete the description of the  Execute  operation, the next diagram focuses the execution of a  Job . In the previous diagram, this step was simplified and only showed that a  Job  instance was created, whose execution produces a  Result  object containing all requested  outputs  as  ProcessData . Hence, a more detailed description of the necessary processing steps is given below:   when the  Engine  is called via the  execute()  method, it first has to retrieve the  IAlgorithm  implementation that is associated to the  process identifier . For this reason, it delegates the retrieval to the  RepositoryManager  that locates the  AlgorithmRepository  containing the  IAlgorithm  implementation for the  process identifier .  from the  IAlgorithm  implementation, its  ProcessDescription  is used to decode the  inputs  as  ProcessInputs  with the help of  ProcessInputDecoder . More information about the decoding of process inputs is provided in section  Binding and Data Handlers for Data Representation/Transformation of Process In- and Outputs  of a separate guide about  Algorithm definitions and the creation of an External Processing Repository .  next, the  JobIdGenerator  component is called to  create()  a new unique  job identifier . Once done, a new  Job  instance is created as  Future  object using the parameters  algorithm ,  job identifier ,  inputs ,  outputs  and  response mode .  the  Job  instance is  submitted  to the  ExecutorService , which is a component that manages and triggers job execution. As the  Job  is also a  Future  object it can be queried for information such as its  status  at any time. Only the  Result  cannot be retrieved right away, since that has to be computed before. However, any  Future  object offers a  get()  method, which will wait, if necessary, to complete the execution and then return the  result . The  Engine  now adds the  Job  to its class property maps  cancelers  and  jobs  and return the  job identifier  to the  ExecuteHandler .  depending on the  execution strategy  the  ExecutorService  will  run()  the execution of the  Job  eventually. The  Job 's  status  is updated to  running  and the  IAlgorithm  implementation is triggered to  execute()  the process.  IAlgorithm  implementation performs the process-specific steps to compute the  outputs . These  outputs  are then properly encoded with the help of  ProcessOutputEncoder  and set as property  nonPersistendResult  of the  Job . The  Job 's  status  is set to  succeeded . Of course, if any error occurred during process execution, then processing is aborted and the  status  is set to  failed  instead.  After successful job completion, the  Engine  is informed via  onJobCompletion()  to  save()  the  Job  information including its  status  and  result  ( outputs ), e.g. on the local hard drive of the server hosting the WPS. Here, the component  ResultPersistence  is used to persist the information.  the  Engine  removes the  Job  from its class property maps  cancelers  and  jobs  and retrieves the persisted  Result  from  ResultPersistence  to return it to the  Job .  the  Job  sets the  Result  and executes any  listeners  that are registered for the event.   Execute Workflow - Job Execution detailed",
            "title": "Execute - Detailed Request Handling"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#getstatus",
            "text": "",
            "title": "GetStatus"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#getstatus-basic-workflow",
            "text": "The aim of the  GetStatus  operation is to retrieve the current  status  of the  job  with the submitted  job identifier . The following coarse workflow diagram shows an exemplar  GetStatus GET  request. The request is parsed by  KvpBinding  as a  GetStatusRequest . Validation is performed by  JobIdParameterValidator , which checks whether a parameter named  jobId  exists whose value can be resolved to an existing  job identifier  within the WPS. Subsequently, the  GetStatusHandler  performs the actual request handling to retrieve the current  job status  and return it within a  GetStatusResponse .  GetStatus Workflow coarse",
            "title": "GetStatus - Basic Workflow"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#getstatus-request-validation",
            "text": "As indicated in the lower diagram, the component  JobIdParameterValidator  performs validation of a  GetStatus  request object. In particular, it extracts the parameter  jobId  from the request object and checks the following conditions:   jobId  is a  NULL  object  the value of  jobId  is a  NULL  object  the value of  jobId  is an  empty  object   If any of these conditions is  true , then a  MissingParameterValueException  is thrown, as the request does not specify a  jobId  parameter value at all. Otherwise, the  jobId  value specified within the request object is checked for validity. In particular, the  Engine  is asked whether it contains a  Job  instance associated to the  jobId . If not, an  InvalidParameterValueException  is thrown. When not exception was thrown, then the  jobId  does point to an existing  Job  and validation was successful.  GetStatus Request Validation",
            "title": "GetStatus - Request Validation"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#getstatus-detailed-request-handling",
            "text": "The details of the  handle()  method of the  GetStatusHandler  are demonstrated in the next diagram. The following sub-tasks are performed:   From the  GetStatusRequest  object the parameters  service ,  version  and  jobId  are extracted. The latter is an identifier pointing to the  Job  instance that has to be present within the  WPS .   The method  getStatus()  from  Engine  is called with  jobId  as parameter. Depending on the existence of a  Job  instance with the specified  jobId  within  engineInstance.jobs , the workflow differs as described below. For one, the job might exist within the memory (e.g. when the job is currently executed or has only been  accepted  but is not running yet) and hence the  job information  can directly be retrieved from the  Job  instance. Otherwise the  job information  has already been persisted (e.g. because the job was finished) and hence has to be retrieved using  ResultPersistence , which retrieves the required information from the persisted resource.   Job exists within engineInstance.jobs and thus exists in memory :  the method  getStatus()  of the existing  Job  instance with identifier  jobId  is called. Within this method, a new  StatusInfo  object is created and filled with relevant information like  job identifier .  from the  Job  instance, the  JobStatus  object can be retrieved, which contains the requested  status information . It is used to set the  status  property within  StatusInfo .  Depending on the  JobStatus , additional information has to be set within  StatusInfo . If the  JobStatus  is  accepted  or  running , then the properties  estimatedCompletion  (date of estimated completion of job),  percentCompleted  and  nextPoll  (information for clients when to re-request the status) are set. Else if the  JobStatus  is  succeeded  or  failed , no additional information is added to  StatusInfo . Actually, the code suggests that an  expiration date  (indicated when the job information is deleted) has to be computed and set, but as of 12.12.2016 there is no implementation yet.  the  StatusInfo  object is then returned and forwarded to  GetStatusHandler .    Job information has been persisted :  here, the job has already finished and its information like  status  or  results  have been previously persisted (e.g. as a JSON file). Hence, this information has to be retrieved from the persisted resource using  ResultPersistence . In consequence, its method  getStatus()  is called using the  jobId  as parameter.  the relevant  job metadata  and  expiration date  are loaded from the persisted job resource via  getJobMetadata(jobId)  and  getExpirationDate(jobId) .  a new instance of  StatusInfo  is created and instantiated with the parameters  jobId  and  expiration date .  a new  JobStatus  object is created from  job metadata  and also set within  StatusInfo .  finally, the  StatusInfo  instance is returned and forwarded to  GetStatusHandler .       A new  GetStatusResponse  is created using  service ,  version  and the retrieved  statusInfo  as parameters. This response object is then returned.    GetStatus - handleRequest detailed",
            "title": "GetStatus - Detailed Request Handling"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#getresult",
            "text": "",
            "title": "GetResult"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#getresult-basic-workflow",
            "text": "A  GetResult  operation is used to retrieve the  result(s)  of the  job  with the submitted  job identifier . The following coarse workflow diagram shows an exemplar  GetResult GET  request. The request is parsed by  KvpBinding  as a  GetResultRequest  and validation is performed by  JobIdParameterValidator , which checks whether the parameter  jobId  points to an existing  job identifier  within the WPS. If so, the  GetResultHandler  performs the actual request handling and returns the requested  output(s)/result(s)  within a  GetResultResponse .  GetResult Workflow coarse",
            "title": "GetResult - Basic Workflow"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#getresult-request-validation",
            "text": "Similar to the validation of a  GetStatus  request, the component  JobIdParameterValidator  performs validation of a  GetResult  request object. Thus, the validation workflow is identical as already described in section  validation of GetStatus request .  GetResult Request Validation",
            "title": "GetResult - Request Validation"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#getresult-detailed-request-handling",
            "text": "Similar to the previous operation descriptions, the following diagram focuses the  handle()  method of  GetResultHandler . In general, the required information is stored within the associated  Job  object, which may or may not have been persisted. If it has not yet been persisted, the result can simply be retrieved from the associated  Job  instance. Otherwise, the information has to be loaded from the persisted resource and the  Result  object has to be constructed from the scratch. Subsequently, both cases are described in detail. The  handle()  method comprises the following sub-tasks:   The parameters  service ,  version  and  jobId  are extracted from the  GetResultRequest  object. The  jobId  is an identifier pointing to the  Job  instance that has to be present within the  WPS .   The method  getResult()  from  Engine  is called with  jobId  as parameter. Depending on the existence of a  Job  instance with the specified  jobId  within  engineInstance.jobs , the workflow differs as described below. For one, the job might exist within the memory (e.g. when the job is currently executed or has only been  accepted  but is not running yet) and hence the  job information  containing the  Result  can directly be retrieved from the  Job  instance. Otherwise the  job information  has already been persisted (e.g. because the job was finished) and hence has to be retrieved using  ResultPersistence , which retrieves the required information from the persisted resource. Bot cases are highlighted in the following:   Job exists within engineInstance.jobs and thus exists in memory :  the  Job  object contains the  Result  object or, if the job is not yet finished, will compute it to guarantee its existence. Since the  Job  instance can directly be fetched from  Engine , it is simply returned, as it contains the  Result .    Job information has been persisted after Job finished (succeeded or failed) :  here, the  job information  was previously persisted and thus has to be reloaded from the associated resource (e.g. a JSON file). Hence, the  getResult()  method of  ResultPersistence  is called with the  jobId  as parameter to refer to the right  Job .  ResultPersistence  now creates a new instance of  Result , which is subsequently instantiated with the relevant information from the persisted  Job  resource. First, the  jobId  is set.  ResultPersistence  loads the  job metadata  from the persisted resource and sets the following properties within the created  Result  object:  expirationDate  (date when the  Job  will permanently be deleted by the  WPS ),  responseMode  (possible values are either  document  for a formal response document or  raw  to request a single  raw output  without surrounding response document),  jobStatus  (possible values may be  succeeded  or  failed  according to  WPS specification )  if  jobStatus  equals  failed , then the job execution was not successful. Hence, the  errorMessage  property is extracted from  job metadata  and used to throw a suitable  Exception .  otherwise (the job was executed without errors and  jobStatus  equals  succeeded ), the computed outputs of the  Job  have to be extracted and set within the  Result  object. For that reason, the property  outputNodes  is extracted from  job metadata . Then a loop over each  outputNode  of  outputNodes  decodes the output information and creates a  ProcessData  instance for each  outputNode . Depending on the  output type  (possible types are  literal ,  complex  or  boundingBox  according to  WPS specification ) and  transmissionMode  (possible modes are  value  or  reference  according to  WPS specification ) the  ProcessData  may represent a  value  output, a  reference  output or a  group data  output.  after each  ProcessData  output is set within  Result  it is returned to  GetResultHandler .       GetResultHandler  creates a new instance of  GetResultResponse  using  service ,  version  and  result  as parameters and returns it.    GetResult - handleRequest detailed",
            "title": "GetResult - Detailed Request Handling"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#dismiss",
            "text": "",
            "title": "Dismiss"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#dismiss-basic-workflow",
            "text": "The  Dismiss  operation is used to cancel an  accepted  or  running   job . A  Dismiss  GET request is parsed by  KvpBinding  as a  DismissRequest . Validation is performed by  JobIdParameterValidator  that checks whether a parameter named  jobId  exists and whether its value can be resolved to an existing  job identifier  within the WPS. Subsequently, the  DismissHandler  processes the request to cancel the specified job if possible and returns a  DismissResponse , which includes the jobs  Status Info  document.  Dismiss Workflow coarse",
            "title": "Dismiss - Basic Workflow"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#dismiss-request-validation",
            "text": "Similar to the validation of a  GetStatus  and  GetResult  request, the component  JobIdParameterValidator  performs validation of a  Dismiss  request object. Thus, the validation workflow is identical as already described in section  validation of GetStatus request .  Dismiss Request Validation",
            "title": "Dismiss - Request Validation"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#dismiss-detailed-request-handling",
            "text": "Again, more detailed information about the sub-tasks within the  handle()  method of  DismissHandler  are explained in the following:   the necessary parameters of the  DismissRequest  are extracted, including  service  (\"WPS\"),  version  (e.g. \"2.0.0\") and  jobId .  after that the  Engine  is informed to  dismiss()  the job with the extracted  jobId . For this reason, the  Engine  retrieves the  Job  and at the same checks whether the job is available as  Cancelable . Here, it has to be considered that the  Engine  manages jobs within multiple class properties, for one the  Job  instances within a  ConcurrentHashMap  and, if their job execution is not yet finished, also as  Cancelable  within a second  ConcurrentHashMap . On completed job execution, the job is removed from the cancelable map.  in consequence, if a job is available as  Cancelable , then its  cancel()  method is called to abort its execution. A  boolean  value indicates whether this event was successful. The subsequent section shows an  process algorithm example  to clarify how an accepted or running job is  dismissed .  the  JobStatus  of the  Job  instance with identifier  jobId  is retrieved and forwarded to the  DismissHandler .  finally, a new  DismissResponse  instance is created from  service  (\"WPS\"),  version  (e.g. \"2.0.0\") and  JobStatus . Hence the response object contains the  status info  document of the dismissed job.   Dismiss - handleRequest detailed",
            "title": "Dismiss - Detailed Request Handling"
        },
        {
            "location": "/sequence_diagrams/workflow_wps_operations/workflow_wps_operations/#cancelling-an-accepted-or-running-job-via-dismiss-an-example-from-the-developer-perspective",
            "text": "Cancelling a  job  before it completes its computation is a key aspect of the  WPS specification . As shown in the previous section, the  Dismiss  operation triggers the WPS server to  cancel()  the execution of a certain  Job .  As explained in section  Execute - Detailed Request Handling , when a  Job  is submitted to the  ExecutorService  that manages process/algorithm execution, a  Future  object is created and added as  Cancelable  to the  Engines  property  engine.cancelers . A  Future  object comprises the method  cancel() , which prevents the  Future  from executing if not already run or interrupts it if currently running. To be precise, if the execution has not started yet, a call to the  cancel()  method prevents the process from starting at all. When the process is already being executed, the  cancel()  method interrupts the thread, in which the  Future  is executed (compare  Oracle Java Doc of Future ). However, interrupting the thread  does not stop the execution directly . Instead the developer of the process/algorithm code explicitly has to consider the  interrupt state  and check it manually in order to abort the execution.  E.g. the following Java code shows an example of an execute method that computes buffer geometries for a list of input geometries. Note that the definition of an  Algorithm  for  JavaPS  is explained in section  How to add new Processes/Algorithms  and thus not explained here. What is important to know is that in- and outputs of an  Algorithm  are stored as Java properties of the implementing class. Within a method annotated by  @Execute  the computation that is called when executing the associated  Job  is implemented. The code below only shows that method. The computation of all the buffer geometries is done within a for-loop that iterates over all input geometries. Within each iteration, the condition  if (Thread.currentThread().isInterrupted())  is called to check whether the thread has been interrupted. If so, then the computation should be aborted, e.g. by the simple statement  return .  \n@Execute\n/**\n * This is an exemplary job execution to show how the\n * \"Dismiss\" operation works and what a Developer has\n * to have in mind when implementing the process\n * execution method\n */\npublic void computeBuffer_dismissable() {\n\n    /*\n     * inputGeometries might be a huge number of geometries\n     * for which a buffer shall be computed\n     */\n    List<Geometry> inputGeometries = this.data;\n    double radius = this.radius;\n\n    List<Geometry> bufferedGeometries = new ArrayList<Geometry>(inputGeometries.size());\n\n    for (Geometry geometry : inputGeometries) {\n\n        /*\n         * before computing the buffer for the current geometry\n         * check if the current thread was interrupted\n         *\n         * if so, then we must manually exit the computation and return!\n         */\n        if (Thread.currentThread().isInterrupted())\n            return;\n\n        /*\n         * else continue computation\n         */\n        else{\n            Geometry buffer = geometry.buffer(radius);\n            bufferedGeometries.add(buffer);\n        }\n}\n\n        /*\n         * computation was successful and we set the output-property\n         * with the computed buffered geometries\n         */\n        this.bufferedOutput = bufferedGeometries;\n    }  Hence, as a developer, you have to take care of properly quitting a running process in case the computation is  cancelled  via a  Dismiss  request. To do so, you have to check  if (Thread.currentThread().isInterrupted())  where applicable. Otherwise, the execution would finish as the  Futures   cancel()  method cannot stop it directly.",
            "title": "Cancelling an accepted or running Job via Dismiss - an Example from the Developer Perspective"
        },
        {
            "location": "/algorithm_definition/algorithm_definition/",
            "text": "JavaPS Documentation - Adding new Processes/Algorithms\n\n\nThis page aims to guide developers on how to create and add new custom processes to \nJavaPS\n. The introduction is split into two main parts. First, the creation of \ncustom algorithms/processes through Java annotations\n is focused. Second, the guide provides recommendations on how to bundle custom \nalgorithm\n definitions within a so-called \nExternal Processing Repository (EPR)\n. In general, it takes more than writing a single Java class to create a new custom \nalgorithm/process\n, as a developer also has to include definitions of appropriate \nbindings\n or \ndata handling\n components assisting in de-/encoding and processing \nin-\n and \noutput data\n. Here, an \nEPR\n may collect all relevant Java components within a stand-alone Maven project, which is separated from JavaPS. Registration of its components is accomplished via Maven and Spring configuration, as explained in section \nRegistration of an EPR within JavaPS via Maven and Spring configuration\n.\n\n\nHow to add custom Processes/Algorithms to JavaPS\n\n\nCustom Algorithm Definitions through Java Annotations\n\n\nAs described in the \nArchitectural Details Page\n, processes are implementations of the interface \nIAlgorithm\n, which prescribes an \nexecute()\n method and a \nTypedProcessDescription\n, the Java representation of a process description. The abstract component \nAbstractAlgorithm\n implements the interface and thus provides the rudimentary skeleton for any \nAlgorithm\n implementation. However, algorithm developers do not have to extend \nAbstractAlgorithm\n themselves. Instead, \nJavaPS\n offers a more elegant and simple way of implementing custom \nAlgorithms\n. Through suitable \nJava annotations\n, any Java class may become an \nAlgorithm\n that is found at application start-up by \nJavaPS\n. This functionality is provided by component \nAnnotatedAlgorithm\n, which extends \nAbstractAlgorithm\n and thus provides a full implementation of the requirements (\nprocess description\n and \nexecute()\n method). The necessary information is automatically parsed and derived from the \nannotations\n.\n\n\nThe following example demonstrates the definition of an \nannotated algorithm\n. The exemplar \n\"TestAlgorithm\"\n is marked as an implementation of \nIAlgorithm\n by annotating certain methods with key annotation, such as \n@Algorithm\n, \n@LiteralInput\n, \n@LiteralOutput\n and \n@Execute\n.\n\n\npackage org.n52.javaps.service;\n\n//import statements omitted\n\n@Algorithm(version = \"1.0.0\")\npublic class TestAlgorithm {\n    private String input1;\n    private String input2;\n    private String output1;\n    private String output2;\n\n    @LiteralInput(identifier = \"input1\")\n    public void setInput1(String value) {\n         this.input1 = value;\n    }\n\n    @LiteralInput(identifier = \"input2\")\n    public void setInput2(String value) {\n         this.input2 = value;\n    }\n\n    @Execute\n    public void execute() {\n         this.output1 = input1;\n         this.output2 = input2;\n    }\n\n    @LiteralOutput(identifier = \"output1\")\n    public String getOutput1() {\n         return this.output1;\n    }\n\n    @LiteralOutput(identifier = \"output2\")\n    public String getOutput2() {\n         return this.output2;\n    }\n\n}\n\n\n\n\nBasically, the Java class is annotated with \n@Algorithm\n to tell \nJavaPS\n, that this class is an \nAlgorithm\n. During initialization, \nJavaPS\n scans through available resources to find all classes marked with \n@Algorithm\n and uses the remaining annotated elements to automatically derive the associated \nProcessDescription\n. In consequence, certain annotations are expected and investigated in order to create the components of the \nProcessDescription\n, such as a single mandatory \n@Excecute\n annotation to declare the functional behaviour of the \nAlgorithm\n or an arbitrary number of process \ninput\n and \noutput\n definitions. Each of the relevant annotations is described in detail below.\n\n\nClass Annotation \n@Algorithm\n\n\nThe annotation \n@Algorithm\n marks a Java class comprises the following additional properties:\n\n\n\n\nString \nidentifier\n: specifies the unique \njob identifier\n of the process; if not set, the \nfully qualified class name\n (Java package and class name) is used\n\n\nString \ntitle\n: the title of the process; can be chosen arbitrarily; if not set, the \nfully qualified class name\n (Java package and class name) is used\n\n\nString \nabstrakt\n: a description of the process to let others know what it can do and how to serve it\n\n\nString \nversion\n: the version of the process\n\n\nBoolean \nstoreSupported\n: \ntrue\n, if the process allows persistence of the results; \ntrue\n per default\n\n\nBoolean \nstatusSupported\n: \ntrue\n, if the process supports status; \ntrue\n per default\n\n\n\n\nAnnotations for the Definition of \nProcess Inputs\n\n\nTypically, a process has one or more \ninputs\n and produces one or more \noutputs\n. Consequently, the \nin-\n and \noutputs\n can be defined via appropriate annotations as well. E.g., the annotation \n@LiteralInput(identifier = \"X\")\n marks a Java \nsetter-method\n that sets the literal input with identifier \"X\". The input itself is stored as a Java class property, which is set by the annotated method when parsing the request and instantiating the \nAlgorithm\n. However, as of January 2017, only \nliteral\n and \ncomplex inputs\n can be defined within \nannotated algorithms\n. Support for \nbounding box inputs\n is not yet implemented. To define a \ncomplex input\n, an \ninput\n \nsetter-method\n may be annotated with \n@ComplexInput\n. In the same way, any \noutput\n may be specified by annotating a suitable \ngetter-method\n with \n@LiteralOutput\n or \n@ComplexOutput\n. Similar to \n@Algorithm\n the \nin-\n and \noutput\n definitions provide additional properties to specify details. Subsequently, these properties are explained:\n\n\nSetter Annotation \n@LiteralInput\n\n\nAnnotation \n@LiteralInput\n Properties\n\n\n\n\nString \nidentifier\n: specifies the unique \ninput identifier\n of the input\n\n\nString \ntitle\n: the title of the input; can be chosen arbitrarily\n\n\nString \nabstrakt\n: a description of the input\n\n\nlong \nminOccurs\n: the minimum number of occurrences within an \nExecute\n request; default value is \"1\"\n\n\nlong \nmaxOccurs\n: the maximum number of occurrences within an \nExecute\n request; default value is \"1\"\n\n\nString \ndefaultValue\n: a default value that is used when the input is not specified within an \nExecute\n request\n\n\nString[] \nallowedValues\n: an array of concrete allowed values for the input;\n\n\nString \nuom\n: specification of the \nunit of measure\n\n\nClass \nbinding\n: reference to a \nbinding\n class that implements/extends \nLiteralType.class\n and thus is able to parse the input from an \nExecute\n request correctly; basically this \nbinding\n component acts as a wrapper for the input; more information about \nbinding\n is provided in section \nThe Role of the Binding Implementations\n\n\n\n\nSetter Annotation \n@ComplexInput\n\n\nAnnotation \n@ComplexInput\n Properties\n\n\n\n\nString \nidentifier\n: specifies the unique \ninput identifier\n of the input\n\n\nString \ntitle\n: the title of the input; can be chosen arbitrarily\n\n\nString \nabstrakt\n: a description of the input\n\n\nlong \nminOccurs\n: the minimum number of occurrences within an \nExecute\n request; default value is \"1\"\n\n\nlong \nmaxOccurs\n: the maximum number of occurrences within an \nExecute\n request; default value is \"1\"\n\n\nlong \nmaximumMegaBytes\n: a limitation of the maximum size of the complex input's payload\n\n\nClass \nbinding\n: reference to a \nbinding\n class that implements/extends \nComplexData.class\n and thus is able to parse the complex input from an \nExecute\n request correctly; basically this \nbinding\n component acts as a wrapper for the input; more information about \nbinding\n is provided in section \nThe Role of the Binding Implementations\n\n\n\n\nAnnotations for the Definition of \nProcess Outputs\n\n\nSetter Annotation \n@LiteralOutput\n\n\nAnnotation \n@LiteralOutput\n Properties\n\n\n\n\nString \nidentifier\n: specifies the unique \noutput identifier\n of the output\n\n\nString \ntitle\n: the title of the output; can be chosen arbitrarily\n\n\nString \nabstrakt\n: a description of the output\n\n\nString \nuom\n: specification of the \nunit of measure\n\n\nClass \nbinding\n: reference to a \nbinding\n class that implements/extends \nLiteralType.class\n and thus is able to encode the output correctly; basically this \nbinding\n component acts as a wrapper for the output; more information about \nbinding\n is provided in section \nThe Role of the Binding Implementations\n\n\n\n\nSetter Annotation \n@ComplexOutput\n\n\nAnnotation \n@ComplexOutput\n Properties\n\n\n\n\nString \nidentifier\n: specifies the unique \noutput identifier\n of the output\n\n\nString \ntitle\n: the title of the output; can be chosen arbitrarily\n\n\nString \nabstrakt\n: a description of the output\n\n\nClass \nbinding\n: reference to a \nbinding\n class that implements/extends \nComplexData.class\n and thus is able to encode the output correctly; basically this \nbinding\n component acts as a wrapper for the output; more information about \nbinding\n is provided in section \nThe Role of the Binding Implementations\n\n\n\n\nThe Role of the Binding Implementations\n\n\nDuring the previous explanation of the annotations for \nin-\n and \noutputs\n, a specific annotation called \nbinding\n was introduced. Its purpose and relevance will be described in this section. In general, a \nWPS\n process defines several process \nin-\n and \noutputs\n. When a client constructs and sends an \nExecute request\n, the \ninputs\n are specified using a certain \nformat/encoding\n. Also the client may request the process \noutput(s)\n to be \nencoded in a certain format\n. While the available \nformats\n are predefined by the \nJavaPS\n implementation of that process, the \nAlgorithm\n implementation uses a single internal representation of the \nin-\n and \noutputs\n. Hence, transformation between the different data representations is necessary.\n\n\nIn essence, a \nJavaPS\n \nAlgorithm\n may internally rely on format \nInternal_A\n to interpret data and perform computations. A client however may send an \nExecute request\n, where the input is specified using different format \nExternal_B\n and the output should be encoded in another format \nExternal_C\n. During process management and execution, the external input representation (\nExternal_B\n) first has to be transformed/decoded into the internal representation (\nInternal_A\n) so the process may use it to compute the result (which again uses the internal data representation of the \nAlgorithm\n implementation). When creating the \nExecute response object\n, the internal representation of the process \noutput/result\n then has to be encoded according to the external format (\nExternal_C\n) as requested by the client.\n\n\nWhenever differences within the data representations of process \nin-\n and \noutputs\n between internal \nAlgorithm\n implementation and external request/response objects occur, a \nbinding\n implementation can be used. It acts as a wrapping component for the internal data representation and provides means to access and manage its data. In collaboration with appropriate \ndata handling\n components, \nbinding\n implementations control the correct transformations between the different internal and external data representations.\n\n\nAs process \nin-\n and \noutputs\n may have different types (e.g. \nliteral\n or \ncomplex\n), a \nbinding\n component must implement the relevant interface. While \nbinding\n classes for \nliteral in-/outputs\n implement the interface \nLiteralData\n, the interface \nComplexData\n has to be implemented by those \nbindings\n that wrap a \ncomplex in-/output\n. A detailed example is provided in the context of an \nExternal Processing Repository (EPR)\n in sub-section \nBinding and Data Handlers for Data Representation/Transformation of Process In- and Outputs\n.\n\n\nAnnotation \n@Execute\n\n\nAfter specifying the \nin-\n and \noutputs\n of the process, only one mandatory annotation/specification is required. Per \nAlgorithm\n one method has to exist that is annotated by \n@Execute\n. This method is called when the process is executed and hence its method body has to compute its \nresult(s)/output(s)\n.\n\n\nConclusion and Recommendation for an \nExternal Processing Repository\n\n\nConcluding, the whole definition of an \nAlgorithm\n can be specified through the appropriate Java annotations. On start-up, the application automatically scans Java resources defined as \nSpring beans\n for classes annotated with \n@Algorithm\n and thus makes them operatable. If necessary, new implementations of \nLiteralType\n or \nComplexData\n (so-called \nbindings\n) may be provided alongside to correctly parse and encode the in- and outputs of the process.\n\n\nIn theory, new implementations may be added within the packages of \nJavaPS\n directly. However, it is recommended to outsource the \nAlgorithm\n implementations into a so-called \nExternal Processing/Algorithm Repository\n, e.g. as stand-alone \nMaven\n project that encapsulates the definitions of all algorithms and necessary \nbinding\n implementations of \nLiteralType\n and \nComplexData\n and accompanying \ndata handlers\n for proper de- and encoding of process \nin-\n and \noutputs\n. Hints and useful information for creating such an external repository are presented below.\n\n\nCreating an External Processing Repository (EPR)\n\n\nIntroduction - What is an EPR?\n\n\nAn \nExternal Processing Repository (EPR)\n bundles \nalgorithm/process\n definitions for \nJavaPS\n in a separate Maven project including necessary \nbinding\n implementations. Within this section, the \nbenefits\n and hints for the \ncreation and contents\n of such an \nEPR\n are presented.\n\n\nBenefits of using an EPR\n\n\nPossible benefits are the clear separation of concerns, as the WPS \nprocess implementations\n are detached from the actual WPS \ninfrastructure implementation\n. Hence, both components can be maintained and developed independent from each other. In addition, by organizing \nprocess implementations\n in external repositories, each repository may include only \nAlgorithms\n within a certain application context (e.g. one repository for geographic/geometric analysis, another for data/format conversions). By docking one or more such thematically specialized repositories on to \nJavaPS\n (through suitable Maven and Spring configuration), subject-oriented WPS instances can be set-up.\n\n\nContents of an EPR - How to write/create an EPR for JavaPS\n\n\nThe following sub-sections concentrate on the required contents of an \nEPR\n and provide developers with a guide on how to create their own \nprocessing repository\n.\n\n\nAn exemplar \nEPR\n for \nJavaPS\n is the 52\u00b0North GitHub-project \njavaps-jts-backend\n. It comprises a single additional \nalgorithm/process\n definition and required other Java components as well as configuration files. JTS stands for \nJava Topology Suite\n, an open source Java library providing spatial processing and analysis functionalities for 2D linear geometries. This project is used as an example to highlight the assets of an \nEPR\n subsequently.\n\n\nIn general, an \nEPR\n adds the following components to the basic \nJavaPS\n WPS infrastructure:\n\n\n\n\nAlgorithm\n definitions through annotated Java classes as described above.\n\n\nBinding\n implementations for de- and encoding of process \nin-\n and \noutputs\n, as described in section \nThe Role of the Binding Implementations\n.\n\n\nIn- and Output Handlers\n: Together with an associated \nBinding\n these handlers provide serviceable data required by the associated \nalgorithm/process\n. This is relevant in the context of \ndata representation\n and its \nde-\n and \nencoding\n, as indicated in the description of \nhandling an Execute request\n. E.g., while in a WPS \nExecute\n request, input geometries might be encoded using \nWell-Known-Text(WKT)\n format, an internal \nalgorithm/process\n within \njavaps-jts-backend\n may require them as proper \nJTS Java objects\n. Furthermore, while the process may use these \nJTS inputs\n to compute certain \nJTS output objects\n, the \nExecute\n response object that is returned to the client could display them as \nWKT\n again (to be precise, the user submits the desired in- and output format within request parameters). In conclusion, \nIn- and Output Handlers\n combined with suitable \nBinding\n implementations take care of proper format transformations between different internal and external representations of process in- and outputs. Section \nJava resources - Exemplar Algorithm/Process Definition of \"JTSConvexHullAlgorithm\"\n explains their coexistence in more detail.\n\n\n\n\nThe presentation of the exemplar \njavaps-jts-backend\n is divided into three parts. First, its \nproject structure\n is shown followed by an explanation of the required \nJava resources\n and finally ends with the necessary \nMaven and Spring configuration\n.\n\n\nProject Structure of exemplar \"javaps-jts-backend\" Algorithm Repository\n\n\nThe \nMaven\n project \njavaps-jts-backend\n is organized as follows. Note that the subsequent project outline only comprises the folders and files related to Maven and the algorithm implementation. Other files, such as GitHub README or licensing information files are neglected and can be inspected on the \nrepository on GitHub\n.\n\n\n\n\njavaps-jts-backend\n\n        |\n        | - \n\"pom.xml\"\n\n        | - \nsrc\n\n             |\n             | - \nmain\n\n                  |\n                  | - \nconfig\n\n                        |\n                        | - ... // additional config file(s), omitted\n                  | - \njava\n\n                        |\n                        | - \norg/n52/geoprocessing/jts\n\n                                |\n                                | - \nalgorithm\n\n                                      |\n                                      | \n\"JTSConvexHullAlgorithm.java\"\n\n                                | - \nio\n\n                                      |\n                                      | - \ndata/binding/complex\n\n                                            |\n                                            | \n\"JTSGeometryBinding.java\"\n\n                                      | - \ndatahandler\n\n                                            |\n                                            | - \ngenerator\n\n                                                  |\n                                                  | - \n\"WKTGenerator.java\"\n\n                                            | - \nparser\n\n                                                  |\n                                                  | - \n\"WKTParser.java\"\n\n                  | - \nresources\n\n                        |\n                        | - \n\"wkt.properties\"\n   \n                        | - \ncomponents\n\n                                |\n                                | - \n\"jts-backend.xml\"\n\n             | - \ntest\n\n                  |\n                  | - ... // omitted\n\n\n\n\nThe general folder structure is predefined by Maven. The project's root tier contains the \npom.xml\n file, which comprises the necessary information regarding dependencies and project building. While Java classes are included in \nsrc/main/java\n relevant resources are located in \nsrc/main/resources\n. \nsrc/test/java\n and \nsrc/test/resources\n complete Mavens project structure and comprise test cases for \nJUnit\n tests. In addition to this mandatory structure, the folder \nsrc/main/config\n comprises relevant configuration files, e.g. containing information related to the Maven build process. Within the scope of this documentation, only the required steps to produce a valid \nprocessing backend/repository\n for \nJavaPS\n are presented. Thus, the following sections focus only on the necessary Java definitions within \nsrc/main/java\n and resource files within \nsrc/main/resources\n.\n\n\nWhile new \nalgorithms/processes\n and related \nbinding\n and \ndata handling\n components are defined through appropriate \nJava implementaions\n) under \nsrc/main/java\n, \nsrc/main/resources\n comprises an \nXML Spring configuration file\n including bean definitions of the implemented Java classes is required to register those components within \nJavaPS\n. Both aspects are described in more detail below.\n\n\nJava resources - Exemplar Algorithm/Process Definition of \"JTSConvexHullAlgorithm\"\n\n\nThis section focuses on the presentation of an exemplar \nAlgorithm\n implementation and related additional Java resources of the \njavaps-jts-backend\n. For clarification, the folder structure and important Java files are given below:\n\n\n\n\njavaps-jts-backend\n\n        |\n        | - \n\"pom.xml\"\n\n        | - \nsrc\n\n             |\n             | - \nmain\n\n                  |\n                  | - \njava\n\n                        |\n                        | - \norg/n52/geoprocessing/jts\n\n                                |\n                                | - \nalgorithm\n\n                                      |\n                                      | \n\"JTSConvexHullAlgorithm.java\"\n\n                                | - \nio\n\n                                      |\n                                      | - \ndata/binding/complex\n\n                                            |\n                                            | \n\"JTSGeometryBinding.java\"\n\n                                      | - \ndatahandler\n\n                                            |\n                                            | - \ngenerator\n\n                                                  |\n                                                  | - \n\"WKTGenerator.java\"\n\n                                            | - \nparser\n\n                                                  |\n                                                  | - \n\"WKTParser.java\"\n\n\n\n\n\nThe \nalgorithm/process\n and related \nbinding\n and \ndata handling\n components are defined in the sub-packages of \nsrc/main/java/\n. To be precise, an implementation of a convex hull algorithm is provided in \norg/n52/geoprocessing/jts/algorithm/JTSConvexHullAlgorithm.java\n. According to \nthe guide on how to add new processes/algorithms to JavaPS\n, this component is the implementation of an \nAnnotatedAlgorithm\n that adds a process to compute the convex hull of an input geometry to \nJavaPS\n. However, in most cases a new \nAlgorithm\n implementation has to be accompanied by additional \nbinding\n and \ndata handling\n components. As mentioned in section \nThe Role of the Binding Implementations\n, those additional components take care of suitable data representation between \nExecute requests\n and the internal \nAlgorithm representation\n including the required transformation (or de- and encoding) steps. Within the scope of the \nJTSConvexHullAlgorithm\n, those components are implemented by the \nbinding\n \nJTSGeometryBinding\n and the two data handlers \nWKTGenerator\n and \nWKTParser\n. Each of these components is introduced in detail subsequently.\n\n\nAlgorithm Definition\n\n\nPackage: \nsrc/main/java/org/n52/geoprocessing/jts/algorithm/\n.\n\n\nComponent: \nJTSConvexHullAlgorithm.java\n\n\nJava Code:\n\n\npackage org.n52.geoprocessing.jts.algorithm;\n\nimport org.n52.geoprocessing.jts.io.data.binding.complex.JTSGeometryBinding;\nimport org.n52.javaps.algorithm.annotation.Algorithm;\nimport org.n52.javaps.algorithm.annotation.ComplexInput;\nimport org.n52.javaps.algorithm.annotation.ComplexOutput;\nimport org.n52.javaps.algorithm.annotation.Execute;\n\nimport com.vividsolutions.jts.geom.Geometry;\n\n/**\n * This algorithm creates a convex hull of a JTS geometry using build the in method.\n * @author BenjaminPross\n *\n */\n@Algorithm(version = \"1.1.0\")\npublic class JTSConvexHullAlgorithm{\n\n    private Geometry result;\n    private Geometry data;\n\n    @ComplexOutput(identifier = \"result\", binding = JTSGeometryBinding.class)\n    public Geometry getResult() {\n        return result;\n    }\n\n    @ComplexInput(identifier = \"data\", binding = JTSGeometryBinding.class)\n    public void setData(Geometry data) {\n        this.data = data;\n    }\n\n    @Execute\n    public void runAlgorithm() {\n        result = data.convexHull();\n    }\n}\n\n\n\n\nThe \nAnnotatedAlgorithm\n \nJTSConvexHullAlgorithm\n is a process implementation for \nJavaPS\n that makes use of the \nJava Topology Suite\n to compute the \nconvex hull\n of an input geometry. It comprises two properties, \ndata\n for the \ninput\n geometry and \nresult\n for the \noutput\n convex hull geometry. Both are of type JTS \nGeometry\n. The \nsetData(Geometry data)\n and \ngetResult()\n methods are annotated by \n@ComplexInput\n and \n@ComplexOutput\n respectively to indicate that both deal with \ncomplex data\n with regard to the WPS specification. Both annotations include the definitions of the \nin-\n and \noutput\n \nidentifier\n as well as the associated \nbinding\n implementation by component \nJTSGeometryBinding.class\n. The latter is explained in the following section. Finally, the annotation \n@Execute\n marks the method \nrunAlgorithm()\n, which will be run on process execution. It computes the convex hull of \ndata\n and stores it in the \nresult\n property.\n\n\nBinding and Data Handlers for Data Representation/Transformation of Process In- and Outputs\n\n\nTo integrate the \nJTSConvexHullAlgorithm\n into JavaPS, additional \nbinding\n and \ndata handler\n components are required to handle data conversion from \nexternal request inputs\n \u2192 \ninternal algorithm data\n and vice versa from \ninternal algorithm data\n \u2192 \nexternal response outputs\n. In particular, the \nJTSConvexHullAlgorithm\n expects input data as JTS \nGeometry\n and it computes its convex hull also as JTS \nGeometry\n. The \njavaps-jts-backend\n however provides a new \nbinding\n and \ndata handlers\n that allow clients to deliver the \ninput data\n and receive \noutput results\n using the \nWKT (Well Known Text)\n format. The \nbinding\n wraps the internal JTS \nGeometry\n and the data handlers integrate into the infrastructure of \nJavaPS\n and take care of converting between \nWKT\n \u2194 \nJTS Geometry\n by relying on the binding. In the following, both aspects are intensified.\n\n\nBinding\n\n\nPackage: \nsrc/main/java/org/n52/geoprocessing/jts/io/data/binding/complex\n\n\nComponent: \nJTSGeometryBinding.java\n\n\nJava Code:\n\n\npackage org.n52.geoprocessing.jts.io.data.binding.complex;\n\nimport org.n52.javaps.io.complex.ComplexData;\n\nimport com.vividsolutions.jts.geom.Geometry;\n\n/**\n * This class wraps a JTS Geometry.\n * @author Benjamin Pross\n *\n */\npublic class JTSGeometryBinding implements ComplexData<Geometry> {\n\n    /**\n     *\n     */\n    private static final long serialVersionUID = 3415522592135759594L;\n    private Geometry geom;\n\n    public JTSGeometryBinding(Geometry geom){\n        this.geom = geom;\n    }\n\n    public Geometry getPayload() {\n        return this.geom;\n    }\n\n    public Class<?> getSupportedClass() {\n        return Geometry.class;\n    }\n\n    public void dispose() {\n\n    }\n\n}\n\n\n\n\nThe \nJTSGeometryBinding\n implements the interface \nComplexData\n and acts as a Wrapper for a JTS \nGeometry\n. Its constructor takes one parameter of type JTS \nGeometry\n that is stored as class property \ngeom\n. The methods \ngetPayload()\n and \ngetSupportedClass()\n are inherited from \nComplexData\n and contain important information required by the infrastructure of \nJavaPS\n. While \ngetSupportedClass()\n points to the Java type that is supported by this \nbinding\n (here \nGeometry.class\n), \ngetPayload()\n retrieves the \nbindings\n actual value (here the wrapped JTS \nGeometry\n instance). From the perspective of \nJavaPS\n the \nsupportedClass\n is required to determine, which \nbindings\n are available for which type of data.\n\n\nData Handlers - Implementations of Interface \"InputOutputHandler\"\n\n\nWhile \nbindings\n wrap a certain type of data, they do not convert between different data representations themselves. Instead, this action is performed by \ndata handlers\n. E.g., the \njavaps-jts-backend\n provides such handlers to manage data transformations of geometric data between \nWKT (Well Known Text)\n \u2194 \nJTS Geometry (via JTSGeometryBinding)\n. Consequently, there is a component \nWKTGenerator\n handling the conversion from \nJTS Geometry (via JTSGeometryBinding)\n \u2192 \nWKT\n and another component \nWKTParser\n that performs the conversion from \nWKT\n \u2192 \nJTS Geometry (via JTSGeometryBinding)\n. To integrate into the infrastructure of \nJavaPS\n, these \ndata handlers\n have to implement certain interfaces and extend certain abstract classes. The following UML class diagram highlights these hierarchy aspects of both components:\n\n\nData Handlers Type Hierarchy\n\n\nThe red coloured abstract classes and interfaces derive from \nJavaPS\n, whereas the magenta coloured components \nWKTGenerator\n and \nWKTParser\n come from \njavaps-jts-backend\n. At the top of the diagram, the central interface \nInputOutputHandler\n prescribes essential methods concerning supported \nformats\n and \nbindings\n that have to be implemented by any \ndata handler\n. Note that for reasons of simplicity, the Java types of the method parameters are neglected within the diagram. On the left, two abstract components \nAbstractInputOutputHandler\n and \nAbstractPropertiesInputOutputHandler\n implement \nInputOutputHandler\n and further provide methods to \nadd\n a new supported \nformat\n or \nbinding\n. It has to be mentioned here that these abstract classes already provide an abstract implementation of the interface methods dictated by \nInputOutputHandler\n. Hence, custom \ndata handlers\n do not have to implement those themselves. In addition, the \nAbstractPropertiesInputOutputHandler\n implements another interface called \nConfigurableClass\n that provides means to fetch available formats from a JSON properties file.\n\n\nOn the right side, the two supplementary interfaces \nInputHandler\n and \nOutputHandler\n inherit from generic \nInputOutputHandler\n and constitute specializations regarding the handling of \nin-\n or \noutputs\n. In particular, \nInputHandler\n prescribes the method \nparse(description, input, format)\n whose task is to \nparse an input from the request object and deliver it as serviceable data for the target algorithm\n. In contrast, \nOutputHandler\n demands a method \ngenerate(description, data, format)\n that should take the \nresult data\n produced by an \nAlgorithm\n and \ngenerate an appropriate output representation for inclusion within a client response object\n.\n\n\nFinally, the actual \ndata handlers\n \nWKTParser\n as well as \nWKTGenerator\n both inherit from \nAbstractPropertiesInputOutputHandler\n and thus inherit the abstract implementation of the generic \nformat\n and \nbinding\n management. Moreover, they implement their counterpart of the two specialized interfaces \nInputHandler\n or \nOutputHandler\n respectively. In consequence, \nWKTParser\n has to implement the \nparse(description, input, format)\n method, while \nWKTGenerator\n must implement \ngenerate(description, data, format)\n.\n\n\nSource Code of WKTParser and WKTGenerator\n\n\nIn the following, the source code of both \ndata handlers\n \nWKTParser\n and \nWKTGenerator\n is presented. Beneath method descriptions the interaction/cooperation with the \nbinding\n component \nJTSGeometryBinding\n is highlighted.\n\n\nWKTParser\n\n\nPackage: \nsrc/main/java/org/n52/geoprocessing/jts/io/datahandler/\n\n\nComponent: and \nparser/WKTParser.java\n\n\nSource Code:\n\n\n//package and import statements omitted\n\n/**\n * This class parses String representations out of JTS Geometries.\n *\n * @author Benjamin Pross\n *\n */\n@Properties(\n        defaultPropertyFileName = \"wkt.properties\")\npublic class WKTParser extends AbstractPropertiesInputOutputHandler implements InputHandler {\n\n    private static Logger LOGGER = LoggerFactory.getLogger(WKTParser.class);\n\n    public WKTParser() {\n        super();\n        addSupportedBinding(JTSGeometryBinding.class);\n    }\n\n    public Data<?> parse(TypedProcessInputDescription<?> description,\n            InputStream input,\n            Format format) throws IOException, DecodingException {\n        try {\n            Geometry g = new WKTReader().read(new InputStreamReader(input));\n\n            return new JTSGeometryBinding(g);\n\n        } catch (ParseException e) {\n            LOGGER.error(e.getMessage(), e);\n        } finally {\n            try {\n                input.close();\n            } catch (IOException e) {\n                LOGGER.error(e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n\n}\n\n\n\n\nWKTParser\n only comprises a default constructor and the \nparse()\n method. The former is used to add/register the associated \nbinding(s)\n and \nformat(s)\n to its internal \nset of supported bindings\n and \nset of supported formats\n. With regard to the \nformats\n, the \nsuper()\n call invokes the \ngetFormatFromProperties()\n method of super class \nAbstractPropertiesInputOutputHandler\n, which expects a \nresource file\n containing entries of JSON encoded \nsupported formats\n. For this reason, the class \nWKTParser\n is annotated with \n@Properties(defaultPropertyFileName = \"wkt.properties\")\n referencing the name of the associated \nresource file\n located in \nsrc/main/resources\n. Its content is displayed below:\n\n\nContent of wkt.properties resource file\n\n\n{\n  \"formats\": [\n  {\"mimeType\":\"application/wkt\", \"default\":true},\n  {\"mimeType\":\"application/wkt\", \"encoding\":\"base64\"}\n  ]\n}\n\n\n\n\nThe JSON array contains valid \nformat definitions\n that are supported by \nWKTParser\n (i.e. \nWKT\n related formats) that, as mentioned above, are registered during its instantiation.\n\n\nConcerning supported \nbindings\n, \nWKTParser\n directly registers them within the constructor via \naddSupportedBinding()\n. Here, only the \nbinding\n \nJTSGeometryBinding\n is supported.\n\n\nThe inherited \nparse()\n method contains the implementation to transform a \nWKT Geometry String\n into a \nJTS Geometry\n using the named \nbinding\n. In particular, a \nWKTReader\n from the \nJava Topology Suite\n is utilized to \nread\n an incoming \nInputStream\n that holds the \nWKT Geometry String\n and produce a \nJTS\n \nGeometry\n instance. Then a new instance of \nJTSGeometryBinding\n is created and returned wrapping the \nJTS\n \nGeometry\n. Afterwards, the \nJavaPS\n infrastructure may use it to set the \ninput\n parameter of the \nJTSConvexHullAlgorithm\n.\n\n\nWKTGenerator\n\n\nPackage: \nsrc/main/java/org/n52/geoprocessing/jts/io/datahandler/\n\n\nComponent: \ngenerator/WKTGenerator.java\n\n\nSource Code:\n\n\n//package and import statements omitted\n\n/**\n * This class generates a String representation out of a JTS Geometry.\n *\n * @author Benjamin Pross\n *\n */\n@Properties(\n        defaultPropertyFileName = \"wkt.properties\")\npublic class WKTGenerator extends AbstractPropertiesInputOutputHandler implements OutputHandler {\n\n    public WKTGenerator() {\n        super();\n        addSupportedBinding(JTSGeometryBinding.class);\n    }\n\n    public InputStream generate(TypedProcessOutputDescription<?> description,\n            Data<?> data,\n            Format format) throws IOException, EncodingException {\n        if (data instanceof JTSGeometryBinding) {\n            Geometry g = ((JTSGeometryBinding) data).getPayload();\n\n            String wktString = new WKTWriter().write(g);\n\n            InputStream is = new ByteArrayInputStream(wktString.getBytes());\n\n            return is;\n        }\n        return null;\n    }\n\n}\n\n\n\n\nSimilar to \nWKTParser\n the implementation of \nWKTGenerator\n comprises an equivalent constructor performing the registration of the same \nformat(s)\n (\nWKT\n related) and \nbinding(s)\n (\nJTSGeometryBinding\n). Moreover, it implements the \ngenerate()\n function inherited by \nOutputHandler\n to convert a \nJTS Geometry\n to a \nWKT String\n \nInputStream\n that can be used for a client response object. In detail, the \ngenerate()\n method includes the relevant \nData<?> data\n object as parameter. In general, it will be delivered using the associated \nbinding\n. In this case, \ndata\n is an instance of \nJTSGeometryBinding\n wrapping the \nJTS\n \nGeometry\n object. From the \nbinding\n, the wrapped content is extracted with the help of \ngetPayload()\n. Then the \nJTS\n \nWKTWriter\n is utilized to \nwrite()\n the \nJTS\n \nGeometry\n object as \nWKT String\n, which is afterwards returned as \nInputStream\n.\n\n\nIn summary, this section highlighted how the presented \ndata handlers\n \nWKTParser\n and \nWKTGenerator\n work in cooperation with their associated \nbinding\n \nJTSGeometryBinding\n to decode request \ninputs\n into serviceable internal Java objects and encode job results into client-specified \noutput\n response representations. As example, the transformation between \nWKT String representations\n and \nJTS Geometry instances\n were focused.\n\n\nRegistration of an EPR within JavaPS via Maven and Spring configuration\n\n\nIn the previous sections the components and functional responsibilities of the \njavaps-jts-backend\n were described. This paragraph explains, how those components have to be registered within \nJavaPS\n. To integrate the \nalgorithms\n, \nbindings\n, \ndata handlers\n and their accompanying resources into the \nJavaPS\n infrastructure, a developer has to do two things: first, create a \nSpring configuration file\n declaring the implemented Java resources as \nSpring beans\n and second \nregister\n the \nEPR\n within \nJavaPS\n. Once both conditions are fulfilled, the \nJavaPS\n infrastructure is capable of identifying the contents of the \nEPR\n (by loading them through the \nSpring configuration file\n) and make them available within its service offerings. Both aspects are described in detail below.\n\n\nSpring Configuration file\n\n\nAs \nJavaPS\n expects \nSpring configuration files\n to be located in \nsrc/main/resources/components\n the configuration file of \njavaps-jts-backend\n is located in \nsrc/main/resources/components/jts-backend.xml\n. Its content is included below:\n\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:util=\"http://www.springframework.org/schema/util\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\n                           http://www.springframework.org/schema/util\n                           http://www.springframework.org/schema/util/spring-util-4.1.xsd\">\n\n    <bean id=\"wktParser\" class=\"org.n52.geoprocessing.jts.io.datahandler.parser.WKTParser\" />\n    <bean id=\"wktGenerator\" class=\"org.n52.geoprocessing.jts.io.datahandler.generator.WKTGenerator\" />\n    <bean id=\"jtsConvexHullAlgorithm\" class=\"org.n52.geoprocessing.jts.algorithm.JTSConvexHullAlgorithm\" />\n\n</beans>\n\n\n\n\nAs described in \nthe JavaPS architecture description\n, JavaPS makes use of \nXML configuration\n for bean declaration. The relevant part of the upper \nSpring configuration file\n includes three bean definitions comprising both \ndata handlers\n (\nWKTParser\n and \nWKTGenerator\n) and the \nAlgorithm\n implementation \nJTSConvexHullAlgorithm\n. By declaring those components of \njavaps-jts-backend\n as \nSpring beans\n, they will be automatically loaded by Spring during startup of the \nJavaPS\n application. Of course, this implies that \njavaps-jts-backend\n is \nregistered\n within \nJavaPS\n as described \nbelow\n.\n\n\nNote that the \nbinding\n implementation is not included as \nSpring bean\n. This is not necessary, as the components \nWKTParser\n and \nWKTGenerator\n explicitly reference it during their initialization.\n\n\nRegistration of EPR within JavaPS\n\n\nRegistration of \nEPRs\n like \njavaps-jts-backend\n may be accomplished through either one of following two ways:\n\n\n\n\nBuild \nJavaPS\n from the scratch with \nEPR\n as dependency:\n\n\nDeclare the stand-alone Maven \nExternal Processing Repository\n project as \ndependency\n within the main \npom.xml\n file of \nJavaPS\n\n\nbuild Maven project \nJavaPS\n with \nEPR\n as dependency, e.g. by executing command \nmvn clean install\n.\n\n\ndeploy the generated \nWAR\n file on a suitable server\n\n\ncheck if custom \nAlgorithm\n of \nEPR\n is available by inspecting the \nContents\n section of the \nCapabilities\n document by calling the \nGetCapabilities\n operation of JavaPS.\n\n\n\n\n\n\nIntegrate \nEPR\n into a running \nJavaPS\n application:\n\n\npackage the stand-alone Maven \nExternal Processing Repository\n project as a \nJAR\n container\n\n\ndrop the \nJAR\n container into folder \nWEB-inf/lib\n of an already deployed \nJavaPS\n application.\n\n\nshutdown and restart the \nJavaPS\n application. The \nEPR\n library should then be found and its contents be added to the \nJavaPS\n infrastructure.\n\n\ncheck if custom \nAlgorithm\n of \nEPR\n is available by inspecting the \nContents\n section of the \nCapabilities\n document by calling the \nGetCapabilities\n operation of JavaPS.",
            "title": "Guide for Creation of custom Algorithms/Processes"
        },
        {
            "location": "/algorithm_definition/algorithm_definition/#javaps-documentation-adding-new-processesalgorithms",
            "text": "This page aims to guide developers on how to create and add new custom processes to  JavaPS . The introduction is split into two main parts. First, the creation of  custom algorithms/processes through Java annotations  is focused. Second, the guide provides recommendations on how to bundle custom  algorithm  definitions within a so-called  External Processing Repository (EPR) . In general, it takes more than writing a single Java class to create a new custom  algorithm/process , as a developer also has to include definitions of appropriate  bindings  or  data handling  components assisting in de-/encoding and processing  in-  and  output data . Here, an  EPR  may collect all relevant Java components within a stand-alone Maven project, which is separated from JavaPS. Registration of its components is accomplished via Maven and Spring configuration, as explained in section  Registration of an EPR within JavaPS via Maven and Spring configuration .",
            "title": "JavaPS Documentation - Adding new Processes/Algorithms"
        },
        {
            "location": "/algorithm_definition/algorithm_definition/#how-to-add-custom-processesalgorithms-to-javaps",
            "text": "",
            "title": "How to add custom Processes/Algorithms to JavaPS"
        },
        {
            "location": "/algorithm_definition/algorithm_definition/#custom-algorithm-definitions-through-java-annotations",
            "text": "As described in the  Architectural Details Page , processes are implementations of the interface  IAlgorithm , which prescribes an  execute()  method and a  TypedProcessDescription , the Java representation of a process description. The abstract component  AbstractAlgorithm  implements the interface and thus provides the rudimentary skeleton for any  Algorithm  implementation. However, algorithm developers do not have to extend  AbstractAlgorithm  themselves. Instead,  JavaPS  offers a more elegant and simple way of implementing custom  Algorithms . Through suitable  Java annotations , any Java class may become an  Algorithm  that is found at application start-up by  JavaPS . This functionality is provided by component  AnnotatedAlgorithm , which extends  AbstractAlgorithm  and thus provides a full implementation of the requirements ( process description  and  execute()  method). The necessary information is automatically parsed and derived from the  annotations .  The following example demonstrates the definition of an  annotated algorithm . The exemplar  \"TestAlgorithm\"  is marked as an implementation of  IAlgorithm  by annotating certain methods with key annotation, such as  @Algorithm ,  @LiteralInput ,  @LiteralOutput  and  @Execute .  package org.n52.javaps.service;\n\n//import statements omitted\n\n@Algorithm(version = \"1.0.0\")\npublic class TestAlgorithm {\n    private String input1;\n    private String input2;\n    private String output1;\n    private String output2;\n\n    @LiteralInput(identifier = \"input1\")\n    public void setInput1(String value) {\n         this.input1 = value;\n    }\n\n    @LiteralInput(identifier = \"input2\")\n    public void setInput2(String value) {\n         this.input2 = value;\n    }\n\n    @Execute\n    public void execute() {\n         this.output1 = input1;\n         this.output2 = input2;\n    }\n\n    @LiteralOutput(identifier = \"output1\")\n    public String getOutput1() {\n         return this.output1;\n    }\n\n    @LiteralOutput(identifier = \"output2\")\n    public String getOutput2() {\n         return this.output2;\n    }\n\n}  Basically, the Java class is annotated with  @Algorithm  to tell  JavaPS , that this class is an  Algorithm . During initialization,  JavaPS  scans through available resources to find all classes marked with  @Algorithm  and uses the remaining annotated elements to automatically derive the associated  ProcessDescription . In consequence, certain annotations are expected and investigated in order to create the components of the  ProcessDescription , such as a single mandatory  @Excecute  annotation to declare the functional behaviour of the  Algorithm  or an arbitrary number of process  input  and  output  definitions. Each of the relevant annotations is described in detail below.",
            "title": "Custom Algorithm Definitions through Java Annotations"
        },
        {
            "location": "/algorithm_definition/algorithm_definition/#class-annotation-algorithm",
            "text": "The annotation  @Algorithm  marks a Java class comprises the following additional properties:   String  identifier : specifies the unique  job identifier  of the process; if not set, the  fully qualified class name  (Java package and class name) is used  String  title : the title of the process; can be chosen arbitrarily; if not set, the  fully qualified class name  (Java package and class name) is used  String  abstrakt : a description of the process to let others know what it can do and how to serve it  String  version : the version of the process  Boolean  storeSupported :  true , if the process allows persistence of the results;  true  per default  Boolean  statusSupported :  true , if the process supports status;  true  per default",
            "title": "Class Annotation @Algorithm"
        },
        {
            "location": "/algorithm_definition/algorithm_definition/#annotations-for-the-definition-of-process-inputs",
            "text": "Typically, a process has one or more  inputs  and produces one or more  outputs . Consequently, the  in-  and  outputs  can be defined via appropriate annotations as well. E.g., the annotation  @LiteralInput(identifier = \"X\")  marks a Java  setter-method  that sets the literal input with identifier \"X\". The input itself is stored as a Java class property, which is set by the annotated method when parsing the request and instantiating the  Algorithm . However, as of January 2017, only  literal  and  complex inputs  can be defined within  annotated algorithms . Support for  bounding box inputs  is not yet implemented. To define a  complex input , an  input   setter-method  may be annotated with  @ComplexInput . In the same way, any  output  may be specified by annotating a suitable  getter-method  with  @LiteralOutput  or  @ComplexOutput . Similar to  @Algorithm  the  in-  and  output  definitions provide additional properties to specify details. Subsequently, these properties are explained:",
            "title": "Annotations for the Definition of Process Inputs"
        },
        {
            "location": "/algorithm_definition/algorithm_definition/#setter-annotation-literalinput",
            "text": "Annotation  @LiteralInput  Properties   String  identifier : specifies the unique  input identifier  of the input  String  title : the title of the input; can be chosen arbitrarily  String  abstrakt : a description of the input  long  minOccurs : the minimum number of occurrences within an  Execute  request; default value is \"1\"  long  maxOccurs : the maximum number of occurrences within an  Execute  request; default value is \"1\"  String  defaultValue : a default value that is used when the input is not specified within an  Execute  request  String[]  allowedValues : an array of concrete allowed values for the input;  String  uom : specification of the  unit of measure  Class  binding : reference to a  binding  class that implements/extends  LiteralType.class  and thus is able to parse the input from an  Execute  request correctly; basically this  binding  component acts as a wrapper for the input; more information about  binding  is provided in section  The Role of the Binding Implementations",
            "title": "Setter Annotation @LiteralInput"
        },
        {
            "location": "/algorithm_definition/algorithm_definition/#setter-annotation-complexinput",
            "text": "Annotation  @ComplexInput  Properties   String  identifier : specifies the unique  input identifier  of the input  String  title : the title of the input; can be chosen arbitrarily  String  abstrakt : a description of the input  long  minOccurs : the minimum number of occurrences within an  Execute  request; default value is \"1\"  long  maxOccurs : the maximum number of occurrences within an  Execute  request; default value is \"1\"  long  maximumMegaBytes : a limitation of the maximum size of the complex input's payload  Class  binding : reference to a  binding  class that implements/extends  ComplexData.class  and thus is able to parse the complex input from an  Execute  request correctly; basically this  binding  component acts as a wrapper for the input; more information about  binding  is provided in section  The Role of the Binding Implementations",
            "title": "Setter Annotation @ComplexInput"
        },
        {
            "location": "/algorithm_definition/algorithm_definition/#annotations-for-the-definition-of-process-outputs",
            "text": "",
            "title": "Annotations for the Definition of Process Outputs"
        },
        {
            "location": "/algorithm_definition/algorithm_definition/#setter-annotation-literaloutput",
            "text": "Annotation  @LiteralOutput  Properties   String  identifier : specifies the unique  output identifier  of the output  String  title : the title of the output; can be chosen arbitrarily  String  abstrakt : a description of the output  String  uom : specification of the  unit of measure  Class  binding : reference to a  binding  class that implements/extends  LiteralType.class  and thus is able to encode the output correctly; basically this  binding  component acts as a wrapper for the output; more information about  binding  is provided in section  The Role of the Binding Implementations",
            "title": "Setter Annotation @LiteralOutput"
        },
        {
            "location": "/algorithm_definition/algorithm_definition/#setter-annotation-complexoutput",
            "text": "Annotation  @ComplexOutput  Properties   String  identifier : specifies the unique  output identifier  of the output  String  title : the title of the output; can be chosen arbitrarily  String  abstrakt : a description of the output  Class  binding : reference to a  binding  class that implements/extends  ComplexData.class  and thus is able to encode the output correctly; basically this  binding  component acts as a wrapper for the output; more information about  binding  is provided in section  The Role of the Binding Implementations",
            "title": "Setter Annotation @ComplexOutput"
        },
        {
            "location": "/algorithm_definition/algorithm_definition/#the-role-of-the-binding-implementations",
            "text": "During the previous explanation of the annotations for  in-  and  outputs , a specific annotation called  binding  was introduced. Its purpose and relevance will be described in this section. In general, a  WPS  process defines several process  in-  and  outputs . When a client constructs and sends an  Execute request , the  inputs  are specified using a certain  format/encoding . Also the client may request the process  output(s)  to be  encoded in a certain format . While the available  formats  are predefined by the  JavaPS  implementation of that process, the  Algorithm  implementation uses a single internal representation of the  in-  and  outputs . Hence, transformation between the different data representations is necessary.  In essence, a  JavaPS   Algorithm  may internally rely on format  Internal_A  to interpret data and perform computations. A client however may send an  Execute request , where the input is specified using different format  External_B  and the output should be encoded in another format  External_C . During process management and execution, the external input representation ( External_B ) first has to be transformed/decoded into the internal representation ( Internal_A ) so the process may use it to compute the result (which again uses the internal data representation of the  Algorithm  implementation). When creating the  Execute response object , the internal representation of the process  output/result  then has to be encoded according to the external format ( External_C ) as requested by the client.  Whenever differences within the data representations of process  in-  and  outputs  between internal  Algorithm  implementation and external request/response objects occur, a  binding  implementation can be used. It acts as a wrapping component for the internal data representation and provides means to access and manage its data. In collaboration with appropriate  data handling  components,  binding  implementations control the correct transformations between the different internal and external data representations.  As process  in-  and  outputs  may have different types (e.g.  literal  or  complex ), a  binding  component must implement the relevant interface. While  binding  classes for  literal in-/outputs  implement the interface  LiteralData , the interface  ComplexData  has to be implemented by those  bindings  that wrap a  complex in-/output . A detailed example is provided in the context of an  External Processing Repository (EPR)  in sub-section  Binding and Data Handlers for Data Representation/Transformation of Process In- and Outputs .",
            "title": "The Role of the Binding Implementations"
        },
        {
            "location": "/algorithm_definition/algorithm_definition/#annotation-execute",
            "text": "After specifying the  in-  and  outputs  of the process, only one mandatory annotation/specification is required. Per  Algorithm  one method has to exist that is annotated by  @Execute . This method is called when the process is executed and hence its method body has to compute its  result(s)/output(s) .",
            "title": "Annotation @Execute"
        },
        {
            "location": "/algorithm_definition/algorithm_definition/#conclusion-and-recommendation-for-an-external-processing-repository",
            "text": "Concluding, the whole definition of an  Algorithm  can be specified through the appropriate Java annotations. On start-up, the application automatically scans Java resources defined as  Spring beans  for classes annotated with  @Algorithm  and thus makes them operatable. If necessary, new implementations of  LiteralType  or  ComplexData  (so-called  bindings ) may be provided alongside to correctly parse and encode the in- and outputs of the process.  In theory, new implementations may be added within the packages of  JavaPS  directly. However, it is recommended to outsource the  Algorithm  implementations into a so-called  External Processing/Algorithm Repository , e.g. as stand-alone  Maven  project that encapsulates the definitions of all algorithms and necessary  binding  implementations of  LiteralType  and  ComplexData  and accompanying  data handlers  for proper de- and encoding of process  in-  and  outputs . Hints and useful information for creating such an external repository are presented below.",
            "title": "Conclusion and Recommendation for an External Processing Repository"
        },
        {
            "location": "/algorithm_definition/algorithm_definition/#creating-an-external-processing-repository-epr",
            "text": "",
            "title": "Creating an External Processing Repository (EPR)"
        },
        {
            "location": "/algorithm_definition/algorithm_definition/#introduction-what-is-an-epr",
            "text": "An  External Processing Repository (EPR)  bundles  algorithm/process  definitions for  JavaPS  in a separate Maven project including necessary  binding  implementations. Within this section, the  benefits  and hints for the  creation and contents  of such an  EPR  are presented.",
            "title": "Introduction - What is an EPR?"
        },
        {
            "location": "/algorithm_definition/algorithm_definition/#benefits-of-using-an-epr",
            "text": "Possible benefits are the clear separation of concerns, as the WPS  process implementations  are detached from the actual WPS  infrastructure implementation . Hence, both components can be maintained and developed independent from each other. In addition, by organizing  process implementations  in external repositories, each repository may include only  Algorithms  within a certain application context (e.g. one repository for geographic/geometric analysis, another for data/format conversions). By docking one or more such thematically specialized repositories on to  JavaPS  (through suitable Maven and Spring configuration), subject-oriented WPS instances can be set-up.",
            "title": "Benefits of using an EPR"
        },
        {
            "location": "/algorithm_definition/algorithm_definition/#contents-of-an-epr-how-to-writecreate-an-epr-for-javaps",
            "text": "The following sub-sections concentrate on the required contents of an  EPR  and provide developers with a guide on how to create their own  processing repository .  An exemplar  EPR  for  JavaPS  is the 52\u00b0North GitHub-project  javaps-jts-backend . It comprises a single additional  algorithm/process  definition and required other Java components as well as configuration files. JTS stands for  Java Topology Suite , an open source Java library providing spatial processing and analysis functionalities for 2D linear geometries. This project is used as an example to highlight the assets of an  EPR  subsequently.  In general, an  EPR  adds the following components to the basic  JavaPS  WPS infrastructure:   Algorithm  definitions through annotated Java classes as described above.  Binding  implementations for de- and encoding of process  in-  and  outputs , as described in section  The Role of the Binding Implementations .  In- and Output Handlers : Together with an associated  Binding  these handlers provide serviceable data required by the associated  algorithm/process . This is relevant in the context of  data representation  and its  de-  and  encoding , as indicated in the description of  handling an Execute request . E.g., while in a WPS  Execute  request, input geometries might be encoded using  Well-Known-Text(WKT)  format, an internal  algorithm/process  within  javaps-jts-backend  may require them as proper  JTS Java objects . Furthermore, while the process may use these  JTS inputs  to compute certain  JTS output objects , the  Execute  response object that is returned to the client could display them as  WKT  again (to be precise, the user submits the desired in- and output format within request parameters). In conclusion,  In- and Output Handlers  combined with suitable  Binding  implementations take care of proper format transformations between different internal and external representations of process in- and outputs. Section  Java resources - Exemplar Algorithm/Process Definition of \"JTSConvexHullAlgorithm\"  explains their coexistence in more detail.   The presentation of the exemplar  javaps-jts-backend  is divided into three parts. First, its  project structure  is shown followed by an explanation of the required  Java resources  and finally ends with the necessary  Maven and Spring configuration .",
            "title": "Contents of an EPR - How to write/create an EPR for JavaPS"
        },
        {
            "location": "/algorithm_definition/algorithm_definition/#project-structure-of-exemplar-javaps-jts-backend-algorithm-repository",
            "text": "The  Maven  project  javaps-jts-backend  is organized as follows. Note that the subsequent project outline only comprises the folders and files related to Maven and the algorithm implementation. Other files, such as GitHub README or licensing information files are neglected and can be inspected on the  repository on GitHub .   javaps-jts-backend \n        |\n        | -  \"pom.xml\" \n        | -  src \n             |\n             | -  main \n                  |\n                  | -  config \n                        |\n                        | - ... // additional config file(s), omitted\n                  | -  java \n                        |\n                        | -  org/n52/geoprocessing/jts \n                                |\n                                | -  algorithm \n                                      |\n                                      |  \"JTSConvexHullAlgorithm.java\" \n                                | -  io \n                                      |\n                                      | -  data/binding/complex \n                                            |\n                                            |  \"JTSGeometryBinding.java\" \n                                      | -  datahandler \n                                            |\n                                            | -  generator \n                                                  |\n                                                  | -  \"WKTGenerator.java\" \n                                            | -  parser \n                                                  |\n                                                  | -  \"WKTParser.java\" \n                  | -  resources \n                        |\n                        | -  \"wkt.properties\"    \n                        | -  components \n                                |\n                                | -  \"jts-backend.xml\" \n             | -  test \n                  |\n                  | - ... // omitted  The general folder structure is predefined by Maven. The project's root tier contains the  pom.xml  file, which comprises the necessary information regarding dependencies and project building. While Java classes are included in  src/main/java  relevant resources are located in  src/main/resources .  src/test/java  and  src/test/resources  complete Mavens project structure and comprise test cases for  JUnit  tests. In addition to this mandatory structure, the folder  src/main/config  comprises relevant configuration files, e.g. containing information related to the Maven build process. Within the scope of this documentation, only the required steps to produce a valid  processing backend/repository  for  JavaPS  are presented. Thus, the following sections focus only on the necessary Java definitions within  src/main/java  and resource files within  src/main/resources .  While new  algorithms/processes  and related  binding  and  data handling  components are defined through appropriate  Java implementaions ) under  src/main/java ,  src/main/resources  comprises an  XML Spring configuration file  including bean definitions of the implemented Java classes is required to register those components within  JavaPS . Both aspects are described in more detail below.",
            "title": "Project Structure of exemplar \"javaps-jts-backend\" Algorithm Repository"
        },
        {
            "location": "/algorithm_definition/algorithm_definition/#java-resources-exemplar-algorithmprocess-definition-of-jtsconvexhullalgorithm",
            "text": "This section focuses on the presentation of an exemplar  Algorithm  implementation and related additional Java resources of the  javaps-jts-backend . For clarification, the folder structure and important Java files are given below:   javaps-jts-backend \n        |\n        | -  \"pom.xml\" \n        | -  src \n             |\n             | -  main \n                  |\n                  | -  java \n                        |\n                        | -  org/n52/geoprocessing/jts \n                                |\n                                | -  algorithm \n                                      |\n                                      |  \"JTSConvexHullAlgorithm.java\" \n                                | -  io \n                                      |\n                                      | -  data/binding/complex \n                                            |\n                                            |  \"JTSGeometryBinding.java\" \n                                      | -  datahandler \n                                            |\n                                            | -  generator \n                                                  |\n                                                  | -  \"WKTGenerator.java\" \n                                            | -  parser \n                                                  |\n                                                  | -  \"WKTParser.java\"   The  algorithm/process  and related  binding  and  data handling  components are defined in the sub-packages of  src/main/java/ . To be precise, an implementation of a convex hull algorithm is provided in  org/n52/geoprocessing/jts/algorithm/JTSConvexHullAlgorithm.java . According to  the guide on how to add new processes/algorithms to JavaPS , this component is the implementation of an  AnnotatedAlgorithm  that adds a process to compute the convex hull of an input geometry to  JavaPS . However, in most cases a new  Algorithm  implementation has to be accompanied by additional  binding  and  data handling  components. As mentioned in section  The Role of the Binding Implementations , those additional components take care of suitable data representation between  Execute requests  and the internal  Algorithm representation  including the required transformation (or de- and encoding) steps. Within the scope of the  JTSConvexHullAlgorithm , those components are implemented by the  binding   JTSGeometryBinding  and the two data handlers  WKTGenerator  and  WKTParser . Each of these components is introduced in detail subsequently.",
            "title": "Java resources - Exemplar Algorithm/Process Definition of \"JTSConvexHullAlgorithm\""
        },
        {
            "location": "/algorithm_definition/algorithm_definition/#algorithm-definition",
            "text": "Package:  src/main/java/org/n52/geoprocessing/jts/algorithm/ .  Component:  JTSConvexHullAlgorithm.java  Java Code:  package org.n52.geoprocessing.jts.algorithm;\n\nimport org.n52.geoprocessing.jts.io.data.binding.complex.JTSGeometryBinding;\nimport org.n52.javaps.algorithm.annotation.Algorithm;\nimport org.n52.javaps.algorithm.annotation.ComplexInput;\nimport org.n52.javaps.algorithm.annotation.ComplexOutput;\nimport org.n52.javaps.algorithm.annotation.Execute;\n\nimport com.vividsolutions.jts.geom.Geometry;\n\n/**\n * This algorithm creates a convex hull of a JTS geometry using build the in method.\n * @author BenjaminPross\n *\n */\n@Algorithm(version = \"1.1.0\")\npublic class JTSConvexHullAlgorithm{\n\n    private Geometry result;\n    private Geometry data;\n\n    @ComplexOutput(identifier = \"result\", binding = JTSGeometryBinding.class)\n    public Geometry getResult() {\n        return result;\n    }\n\n    @ComplexInput(identifier = \"data\", binding = JTSGeometryBinding.class)\n    public void setData(Geometry data) {\n        this.data = data;\n    }\n\n    @Execute\n    public void runAlgorithm() {\n        result = data.convexHull();\n    }\n}  The  AnnotatedAlgorithm   JTSConvexHullAlgorithm  is a process implementation for  JavaPS  that makes use of the  Java Topology Suite  to compute the  convex hull  of an input geometry. It comprises two properties,  data  for the  input  geometry and  result  for the  output  convex hull geometry. Both are of type JTS  Geometry . The  setData(Geometry data)  and  getResult()  methods are annotated by  @ComplexInput  and  @ComplexOutput  respectively to indicate that both deal with  complex data  with regard to the WPS specification. Both annotations include the definitions of the  in-  and  output   identifier  as well as the associated  binding  implementation by component  JTSGeometryBinding.class . The latter is explained in the following section. Finally, the annotation  @Execute  marks the method  runAlgorithm() , which will be run on process execution. It computes the convex hull of  data  and stores it in the  result  property.",
            "title": "Algorithm Definition"
        },
        {
            "location": "/algorithm_definition/algorithm_definition/#binding-and-data-handlers-for-data-representationtransformation-of-process-in-and-outputs",
            "text": "To integrate the  JTSConvexHullAlgorithm  into JavaPS, additional  binding  and  data handler  components are required to handle data conversion from  external request inputs  \u2192  internal algorithm data  and vice versa from  internal algorithm data  \u2192  external response outputs . In particular, the  JTSConvexHullAlgorithm  expects input data as JTS  Geometry  and it computes its convex hull also as JTS  Geometry . The  javaps-jts-backend  however provides a new  binding  and  data handlers  that allow clients to deliver the  input data  and receive  output results  using the  WKT (Well Known Text)  format. The  binding  wraps the internal JTS  Geometry  and the data handlers integrate into the infrastructure of  JavaPS  and take care of converting between  WKT  \u2194  JTS Geometry  by relying on the binding. In the following, both aspects are intensified.",
            "title": "Binding and Data Handlers for Data Representation/Transformation of Process In- and Outputs"
        },
        {
            "location": "/algorithm_definition/algorithm_definition/#binding",
            "text": "Package:  src/main/java/org/n52/geoprocessing/jts/io/data/binding/complex  Component:  JTSGeometryBinding.java  Java Code:  package org.n52.geoprocessing.jts.io.data.binding.complex;\n\nimport org.n52.javaps.io.complex.ComplexData;\n\nimport com.vividsolutions.jts.geom.Geometry;\n\n/**\n * This class wraps a JTS Geometry.\n * @author Benjamin Pross\n *\n */\npublic class JTSGeometryBinding implements ComplexData<Geometry> {\n\n    /**\n     *\n     */\n    private static final long serialVersionUID = 3415522592135759594L;\n    private Geometry geom;\n\n    public JTSGeometryBinding(Geometry geom){\n        this.geom = geom;\n    }\n\n    public Geometry getPayload() {\n        return this.geom;\n    }\n\n    public Class<?> getSupportedClass() {\n        return Geometry.class;\n    }\n\n    public void dispose() {\n\n    }\n\n}  The  JTSGeometryBinding  implements the interface  ComplexData  and acts as a Wrapper for a JTS  Geometry . Its constructor takes one parameter of type JTS  Geometry  that is stored as class property  geom . The methods  getPayload()  and  getSupportedClass()  are inherited from  ComplexData  and contain important information required by the infrastructure of  JavaPS . While  getSupportedClass()  points to the Java type that is supported by this  binding  (here  Geometry.class ),  getPayload()  retrieves the  bindings  actual value (here the wrapped JTS  Geometry  instance). From the perspective of  JavaPS  the  supportedClass  is required to determine, which  bindings  are available for which type of data.",
            "title": "Binding"
        },
        {
            "location": "/algorithm_definition/algorithm_definition/#data-handlers-implementations-of-interface-inputoutputhandler",
            "text": "While  bindings  wrap a certain type of data, they do not convert between different data representations themselves. Instead, this action is performed by  data handlers . E.g., the  javaps-jts-backend  provides such handlers to manage data transformations of geometric data between  WKT (Well Known Text)  \u2194  JTS Geometry (via JTSGeometryBinding) . Consequently, there is a component  WKTGenerator  handling the conversion from  JTS Geometry (via JTSGeometryBinding)  \u2192  WKT  and another component  WKTParser  that performs the conversion from  WKT  \u2192  JTS Geometry (via JTSGeometryBinding) . To integrate into the infrastructure of  JavaPS , these  data handlers  have to implement certain interfaces and extend certain abstract classes. The following UML class diagram highlights these hierarchy aspects of both components:  Data Handlers Type Hierarchy  The red coloured abstract classes and interfaces derive from  JavaPS , whereas the magenta coloured components  WKTGenerator  and  WKTParser  come from  javaps-jts-backend . At the top of the diagram, the central interface  InputOutputHandler  prescribes essential methods concerning supported  formats  and  bindings  that have to be implemented by any  data handler . Note that for reasons of simplicity, the Java types of the method parameters are neglected within the diagram. On the left, two abstract components  AbstractInputOutputHandler  and  AbstractPropertiesInputOutputHandler  implement  InputOutputHandler  and further provide methods to  add  a new supported  format  or  binding . It has to be mentioned here that these abstract classes already provide an abstract implementation of the interface methods dictated by  InputOutputHandler . Hence, custom  data handlers  do not have to implement those themselves. In addition, the  AbstractPropertiesInputOutputHandler  implements another interface called  ConfigurableClass  that provides means to fetch available formats from a JSON properties file.  On the right side, the two supplementary interfaces  InputHandler  and  OutputHandler  inherit from generic  InputOutputHandler  and constitute specializations regarding the handling of  in-  or  outputs . In particular,  InputHandler  prescribes the method  parse(description, input, format)  whose task is to  parse an input from the request object and deliver it as serviceable data for the target algorithm . In contrast,  OutputHandler  demands a method  generate(description, data, format)  that should take the  result data  produced by an  Algorithm  and  generate an appropriate output representation for inclusion within a client response object .  Finally, the actual  data handlers   WKTParser  as well as  WKTGenerator  both inherit from  AbstractPropertiesInputOutputHandler  and thus inherit the abstract implementation of the generic  format  and  binding  management. Moreover, they implement their counterpart of the two specialized interfaces  InputHandler  or  OutputHandler  respectively. In consequence,  WKTParser  has to implement the  parse(description, input, format)  method, while  WKTGenerator  must implement  generate(description, data, format) .  Source Code of WKTParser and WKTGenerator  In the following, the source code of both  data handlers   WKTParser  and  WKTGenerator  is presented. Beneath method descriptions the interaction/cooperation with the  binding  component  JTSGeometryBinding  is highlighted.  WKTParser  Package:  src/main/java/org/n52/geoprocessing/jts/io/datahandler/  Component: and  parser/WKTParser.java  Source Code:  //package and import statements omitted\n\n/**\n * This class parses String representations out of JTS Geometries.\n *\n * @author Benjamin Pross\n *\n */\n@Properties(\n        defaultPropertyFileName = \"wkt.properties\")\npublic class WKTParser extends AbstractPropertiesInputOutputHandler implements InputHandler {\n\n    private static Logger LOGGER = LoggerFactory.getLogger(WKTParser.class);\n\n    public WKTParser() {\n        super();\n        addSupportedBinding(JTSGeometryBinding.class);\n    }\n\n    public Data<?> parse(TypedProcessInputDescription<?> description,\n            InputStream input,\n            Format format) throws IOException, DecodingException {\n        try {\n            Geometry g = new WKTReader().read(new InputStreamReader(input));\n\n            return new JTSGeometryBinding(g);\n\n        } catch (ParseException e) {\n            LOGGER.error(e.getMessage(), e);\n        } finally {\n            try {\n                input.close();\n            } catch (IOException e) {\n                LOGGER.error(e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n\n}  WKTParser  only comprises a default constructor and the  parse()  method. The former is used to add/register the associated  binding(s)  and  format(s)  to its internal  set of supported bindings  and  set of supported formats . With regard to the  formats , the  super()  call invokes the  getFormatFromProperties()  method of super class  AbstractPropertiesInputOutputHandler , which expects a  resource file  containing entries of JSON encoded  supported formats . For this reason, the class  WKTParser  is annotated with  @Properties(defaultPropertyFileName = \"wkt.properties\")  referencing the name of the associated  resource file  located in  src/main/resources . Its content is displayed below:  Content of wkt.properties resource file  {\n  \"formats\": [\n  {\"mimeType\":\"application/wkt\", \"default\":true},\n  {\"mimeType\":\"application/wkt\", \"encoding\":\"base64\"}\n  ]\n}  The JSON array contains valid  format definitions  that are supported by  WKTParser  (i.e.  WKT  related formats) that, as mentioned above, are registered during its instantiation.  Concerning supported  bindings ,  WKTParser  directly registers them within the constructor via  addSupportedBinding() . Here, only the  binding   JTSGeometryBinding  is supported.  The inherited  parse()  method contains the implementation to transform a  WKT Geometry String  into a  JTS Geometry  using the named  binding . In particular, a  WKTReader  from the  Java Topology Suite  is utilized to  read  an incoming  InputStream  that holds the  WKT Geometry String  and produce a  JTS   Geometry  instance. Then a new instance of  JTSGeometryBinding  is created and returned wrapping the  JTS   Geometry . Afterwards, the  JavaPS  infrastructure may use it to set the  input  parameter of the  JTSConvexHullAlgorithm .  WKTGenerator  Package:  src/main/java/org/n52/geoprocessing/jts/io/datahandler/  Component:  generator/WKTGenerator.java  Source Code:  //package and import statements omitted\n\n/**\n * This class generates a String representation out of a JTS Geometry.\n *\n * @author Benjamin Pross\n *\n */\n@Properties(\n        defaultPropertyFileName = \"wkt.properties\")\npublic class WKTGenerator extends AbstractPropertiesInputOutputHandler implements OutputHandler {\n\n    public WKTGenerator() {\n        super();\n        addSupportedBinding(JTSGeometryBinding.class);\n    }\n\n    public InputStream generate(TypedProcessOutputDescription<?> description,\n            Data<?> data,\n            Format format) throws IOException, EncodingException {\n        if (data instanceof JTSGeometryBinding) {\n            Geometry g = ((JTSGeometryBinding) data).getPayload();\n\n            String wktString = new WKTWriter().write(g);\n\n            InputStream is = new ByteArrayInputStream(wktString.getBytes());\n\n            return is;\n        }\n        return null;\n    }\n\n}  Similar to  WKTParser  the implementation of  WKTGenerator  comprises an equivalent constructor performing the registration of the same  format(s)  ( WKT  related) and  binding(s)  ( JTSGeometryBinding ). Moreover, it implements the  generate()  function inherited by  OutputHandler  to convert a  JTS Geometry  to a  WKT String   InputStream  that can be used for a client response object. In detail, the  generate()  method includes the relevant  Data<?> data  object as parameter. In general, it will be delivered using the associated  binding . In this case,  data  is an instance of  JTSGeometryBinding  wrapping the  JTS   Geometry  object. From the  binding , the wrapped content is extracted with the help of  getPayload() . Then the  JTS   WKTWriter  is utilized to  write()  the  JTS   Geometry  object as  WKT String , which is afterwards returned as  InputStream .  In summary, this section highlighted how the presented  data handlers   WKTParser  and  WKTGenerator  work in cooperation with their associated  binding   JTSGeometryBinding  to decode request  inputs  into serviceable internal Java objects and encode job results into client-specified  output  response representations. As example, the transformation between  WKT String representations  and  JTS Geometry instances  were focused.",
            "title": "Data Handlers - Implementations of Interface \"InputOutputHandler\""
        },
        {
            "location": "/algorithm_definition/algorithm_definition/#registration-of-an-epr-within-javaps-via-maven-and-spring-configuration",
            "text": "In the previous sections the components and functional responsibilities of the  javaps-jts-backend  were described. This paragraph explains, how those components have to be registered within  JavaPS . To integrate the  algorithms ,  bindings ,  data handlers  and their accompanying resources into the  JavaPS  infrastructure, a developer has to do two things: first, create a  Spring configuration file  declaring the implemented Java resources as  Spring beans  and second  register  the  EPR  within  JavaPS . Once both conditions are fulfilled, the  JavaPS  infrastructure is capable of identifying the contents of the  EPR  (by loading them through the  Spring configuration file ) and make them available within its service offerings. Both aspects are described in detail below.",
            "title": "Registration of an EPR within JavaPS via Maven and Spring configuration"
        },
        {
            "location": "/algorithm_definition/algorithm_definition/#spring-configuration-file",
            "text": "As  JavaPS  expects  Spring configuration files  to be located in  src/main/resources/components  the configuration file of  javaps-jts-backend  is located in  src/main/resources/components/jts-backend.xml . Its content is included below:  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:util=\"http://www.springframework.org/schema/util\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\n                           http://www.springframework.org/schema/util\n                           http://www.springframework.org/schema/util/spring-util-4.1.xsd\">\n\n    <bean id=\"wktParser\" class=\"org.n52.geoprocessing.jts.io.datahandler.parser.WKTParser\" />\n    <bean id=\"wktGenerator\" class=\"org.n52.geoprocessing.jts.io.datahandler.generator.WKTGenerator\" />\n    <bean id=\"jtsConvexHullAlgorithm\" class=\"org.n52.geoprocessing.jts.algorithm.JTSConvexHullAlgorithm\" />\n\n</beans>  As described in  the JavaPS architecture description , JavaPS makes use of  XML configuration  for bean declaration. The relevant part of the upper  Spring configuration file  includes three bean definitions comprising both  data handlers  ( WKTParser  and  WKTGenerator ) and the  Algorithm  implementation  JTSConvexHullAlgorithm . By declaring those components of  javaps-jts-backend  as  Spring beans , they will be automatically loaded by Spring during startup of the  JavaPS  application. Of course, this implies that  javaps-jts-backend  is  registered  within  JavaPS  as described  below .  Note that the  binding  implementation is not included as  Spring bean . This is not necessary, as the components  WKTParser  and  WKTGenerator  explicitly reference it during their initialization.",
            "title": "Spring Configuration file"
        },
        {
            "location": "/algorithm_definition/algorithm_definition/#registration-of-epr-within-javaps",
            "text": "Registration of  EPRs  like  javaps-jts-backend  may be accomplished through either one of following two ways:   Build  JavaPS  from the scratch with  EPR  as dependency:  Declare the stand-alone Maven  External Processing Repository  project as  dependency  within the main  pom.xml  file of  JavaPS  build Maven project  JavaPS  with  EPR  as dependency, e.g. by executing command  mvn clean install .  deploy the generated  WAR  file on a suitable server  check if custom  Algorithm  of  EPR  is available by inspecting the  Contents  section of the  Capabilities  document by calling the  GetCapabilities  operation of JavaPS.    Integrate  EPR  into a running  JavaPS  application:  package the stand-alone Maven  External Processing Repository  project as a  JAR  container  drop the  JAR  container into folder  WEB-inf/lib  of an already deployed  JavaPS  application.  shutdown and restart the  JavaPS  application. The  EPR  library should then be found and its contents be added to the  JavaPS  infrastructure.  check if custom  Algorithm  of  EPR  is available by inspecting the  Contents  section of the  Capabilities  document by calling the  GetCapabilities  operation of JavaPS.",
            "title": "Registration of EPR within JavaPS"
        }
    ]
}